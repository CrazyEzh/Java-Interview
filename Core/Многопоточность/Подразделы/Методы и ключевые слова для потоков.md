---
up: [[Многопоточность]]
---
# Методы и ключевые слова для потоков
---
### Чем отличаются методы wait() и sleep()?
* метод sleep() - приостанавливает поток на указанное время. Состояние меняется на WAITING, по истечению - RUNNABLE.  
* метод wait() - меняет состояние потока на WAITING. Может быть вызван только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException

### Как работают методы wait(), notify() и notifyAll()?
* **wait():** **освобождает монитор** и **переводит вызывающий поток** в состояние **ожидания** до тех пор, **пока другой поток не вызовет метод notify()/notifyAll();**  
* **notify():** **продолжает** работу **потока**, у которого ранее был вызван метод wait();  
* **notifyAll():** **возобновляет** работу **всех** **потоков**, у которых ранее был вызван метод wait().  
Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод **notify()** **подаёт сигнал** одному из **потоков**, **ожидающих на объекте**, **чтобы перейти в состояние Работоспособный (Runnable)**. При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). **Если ни один поток не находится в ожидании на методе wait(),** т**о при вызове notify() или notifyAll() ничего не происходит.**  
wait(), notify() и notifyAll() **должны** вызываться **только из синхронизированного кода.**

### Что за ключевые слова - transient и volatile?
Когда экземпляр переменной объявлен как transient, его значение не должно удерживаться, когда объект сериализуется.
Модификатор volatile сообщает компилятору, что переменная, модифицированная с помощью volatile, может быть неожиданно изменена другими частями вашей программы

### Что означает ключевое слово volatile? Почему операции над volatile переменными не атомарны?
**Переменная volatile является атомарной для чтения, но операции над переменной НЕ являются атомарными. Поля, для которых неприемлемо увидеть «несвежее» (stale) значение в результате кэширования или переупорядочения.**  
Если происходит какая-то операция, например, инкримент, то атомарность уже не обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3). Такая операция не является атомарной и в неё может вклиниться поток по середине.  
Атомарная операция выглядит единой и неделимой командой процессора.  
**Переменная volatile находится в хипе, а не в кэше стека .**

### Можно ли вызвать start() для одного потока дважды?
Нельзя стартовать поток больше, чем единожды. В частности, поток не может быть перезапущен, если он уже завершил выполнение.  
Выдает: IllegalThreadStateException

### Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted()
Как остановить поток?  
На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки).  
**Для корректной остановки потока** можно использовать метод класса Thread - **interrupt().** Этот метод выставляет внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). **Метод interrupt() также способен вывести поток из состояния ожидания или спячки**. Т.е. если у потока были вызваны методы sleep() или wait() – текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.  
**Схема действия** при этом получается следующей:
**Реализовать поток.  
В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted().  
**Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.  
Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.  
Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO.

**Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог interrupt().** Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile).

**Почему не рекомендуется использовать метод Thread.stop()?  
При принудительной остановке (приостановке) потока, stop() прерывает поток в недетерменированном месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны?** Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы?

**В чем разница между interrupted() и isInterrupted()?  
**Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг. Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.  
Когда прерванный поток проверяет статус прерывания, вызывая **статический метод Thread.interrupted(), статус прерывания сбрасывается.**  
**Нестатический метод isInterrupted()** используется одним потоком для проверки статуса прерывания у другого потока, **не изменяя флаг прерывания.**

### Что означает ключевое слово synchronized? Где и для чего может использоваться?
Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.