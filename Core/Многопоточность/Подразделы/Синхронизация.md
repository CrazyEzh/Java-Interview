---
up: [[Многопоточность]]
---
# Синхронизация
---
### Что такое синхронизация? Какие способы синхронизации существуют в java?
Синхронизация это **процесс**, **который позволяет выполнять потоки параллельно. 

**В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. 
Способы синхронизации в Java:  
Системная синхронизация с использованием wait()/notify().**  
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!  
**Системная синхронизация с использованием join()**.  
Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.  
**Использование классов из пакета java.util.concurrent.Locks -** механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: **Lock, Condition, ReadWriteLock.**

### Что такое монитор? Как монитор реализован в java?
Монитор - (средство обеспечения контроля за доступом к ресурсу)механизм синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам. Частью монитора является mutex, который встроен в класс Object и имеется у каждого объекта.  
Удобно представлять mutex как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.  
В Java **монитор реализован с помощью ключевого слова synchronized.**

### Зачем нужен ExecutorService?
ExecutorService нужен для экономии ресурсов. Он позволяет создать определенное количество потоков, переиспользовать и управлять ими, избавляя от необходимости каждый раз создавать новый поток.

### Что такое deadlock?
Взаимная блокировка (deadlock) - **явление** при котором **все** **потоки** находятся **в режиме ожидания и своё состояние не меняют.** Происходит, когда достигаются состояния:  
**взаимного исключения:** по крайней мере **один** ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в данный момент времени.  
**удержания и ожидания:** поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые удерживаются другими потоками.  
**отсутствия предочистки:** операционная система не переназначает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.  
**цикличного ожидания:** поток ждет освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.  
Простейший способ **избежать взаимной блокировки** – **не допускать цикличного ожидания.** Этого **можно достичь**, **получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.**

### Что такое семафор? Как он реализован в Java?
**Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор**. Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.

### Что такое FutureTask?
FutureTask представляет собой **отменяемое** **асинхронное** **вычисление** в **параллельном** **потоке**. Этот **класс** предоставляет **базовую реализацию Future**, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. **Результат может быть получен только когда вычисление завершено**, **метод получения будет заблокирован, если вычисление ещё не завершено**. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как **FutureTask помимо Future реализует Runnable**, его можно передать в Executor на выполнение.

### Что такое livelock?
livelock – **тип взаимной блокировки**, при котором **несколько потоков выполняют бесполезную работу**, **попадая** в **зацикленность** **при попытке получения** каких-либо **ресурсов**. При этом **их состояния** постоянно **изменяются** в **зависимости друг от друга.** Фактической **ошибки не возникает**, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.  
Реальный **пример** livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.

### Что является монитором у статического synchronized-метода?
Объект типа Class, соответствующий классу, в котором определен метод.

### Что является монитором у нестатического synchronized-метода?
Объект this

### Что такое Фреймворк fork/join? Для чего он нужен?
Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. **Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.**  
**Этап Fork**: **большая задача разделяется** на **несколько меньших подзадач,** которые в свою очередь также разбиваются на меньшие. **И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.**  
**Этап Join:** далее (опционально) идёт процесс «свёртки» - **решения подзадач некоторым образом объединяются пока не получится решение всей задачи.**  
Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.  
Для **решения** **некоторых** задач **этап Join не требуется. Например**, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.  
Ещё одно **преимущество** этого фреймворка заключается в том, что он **использует work-stealing алгоритм**: **потоки**, которые **завершили** выполнение **собственных подзадач**, могут «**украсть**» **подзадачи** **у** других **потоков**, **которые** **всё ещё заняты.**

### util. Concurrent поверхностно
Классы и интерфейсы пакета java.util.concurrent объедининены в несколько групп по функциональному признаку:  
  
**collections** - Набор эффективно работающих в многопоточной среде коллекций. CopyOnWriteArrayList(Set), ConcurrentHashMap.  
Итераторы классов данного пакета представляют данные на определенный момент времени. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не будет ConcurrentModificationException.

Отличие **ConcurrentHashMap** связано с внутренней структурой хранения пар key-value. СoncurrentHashMap использует несколько сегментов, и данный класс нужно рассматривать как группу HashMap’ов. Количество сегментов по умолчанию равно 16. Если пара key-value хранится в 10-ом сегменте, то ConcurrentHashMap заблокирует, при необходимости, только 10-й сегмент, и не будет блокировать остальные 15.

**CopyOnWriteArrayList:**
* volatile массив внутри  
* lock только при модификации списка, поэтому операции чтения очень быстрые  
* новая копия массива при модификации  
* fail-fast итератор  
* модификация через iterator невозможна - UnsupportedOperationException

**synchronizers** - Объекты синхронизации, позволяющие разработчику управлять и/или ограничивать работу нескольких потоков. Cодержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser.

* **CountDownLatch** - объект синхронизации потоков, блокирующий один или несколько потоков до тех пор, пока не будут выполнены определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий, блокировки выполняемых потоков будут сняты и они продолжат выполнение кода. Одноразовый.  
* **CyclicBarrier** — барьерная синхронизация останавливает поток в определенном месте в ожидании прихода остальных потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается. Как и CountDownLatch, использует счетчик и похож на него. Отличие связано с тем, барьер можно использовать повторно(в цикле).  
* **Exchanger** — объект синхронизации, используемый для двустороннего обмена данными между двумя потоками. При обмене данными допускается null значения, что позволяет использовать класс для односторонней передачи объекта или же просто, как синхронизатор двух потоков. Обмен данными выполняется вызовом метода exchange, сопровождаемый самоблокировкой потока. Как только второй поток вызовет метод exchange, то синхронизатор Exchanger выполнит обмен данными между потоками.  
* **Phaser** — объект синхронизации типа «Барьер», но, в отличие от CyclicBarrier, может иметь несколько барьеров (фаз), и количество участников на каждой фазе может быть разным.

**atomic** - Набор атомарных классов для выполнения атомарных операций. Операция является атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized.  
**Queues** - содержит классы формирования неблокирующих и блокирующих очередей для многопоточных приложений. Неблокирующие очереди «заточены» на скорость выполнения, блокирующие очереди приостанавливают потоки при работе с очередью.  
**Locks** - Механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.

Lock — базовый интерфейс, предоставляющий более гибкий подход при ограничении доступа к ресурсам/блокам по сравнению с использованием synchronized. Так, при использовании нескольких блокировок, порядок их освобождения может быть произвольный. Имеется возможность перехода к альтернативному сценарию, если блокировка уже захвачена.  
  
Condition — интерфейсное условие в сочетании с блокировкой Lock позволяет заменить методы монитора/мьютекса (wait, notify и notifyAll) объектом, управляющим ожиданием событий. Объект с условием чаще всего получается из блокировок с использованием метода lock.newCondition(). Таким образом можно получить несколько комплектов wait/notify для одного объекта. Блокировка Lock заменяет использование synchronized, а Condition — объектные методы монитора.  
  
ReadWriteLock — интерфейс создания read/write блокировок, который реализует один единственный класс ReentrantReadWriteLock. Блокировку чтение-запись следует использовать при длительных и частых операциях чтения и редких операциях записи. Тогда при доступе к защищенному ресурсу используются разные методы блокировки, как показано ниже :  
  
ReadWriteLock rwl = new ReentrantReadWriteLock();  
Lock readLock = rwl.readLock();  
Lock writeLock = rwl.writeLock();

**Executors** - включает средства, называемые сервисами исполнения, позволяющие управлять потоковыми задачами с возможностью получения результатов через интерфейсы Future и Callable.

**ExecutorService** служит альтернативой классу Thread, предназначенному для управления потоками. В основу сервиса исполнения положен интерфейс Executor, в котором определен один метод :  
void execute(Runnable thread);  
При вызове метода execute исполняется поток thread.

### Stream API & ForkJoinPool. Как связаны, что это такое
В Stream API есть простой способ распараллеливания потока метедом parallel() или parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах.  
По-умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается статически и живет пока не будет вызван System::exit. Если задачам не указывать конкретный пул, то они будут исполняться в рамках commonPool.  
По-умолчанию, размер пула равен на 1 меньше, чем количество доступных ядер.  
Когда некий тред отправляет задачу в common pool, то пул может использовать вызывающий тред (caller-thread) в качестве воркера. ForkJoinPool пытается загрузить своими задачами и вызывающий тред.