---
up: [[Многопоточность]]
---
# Потоки(Threads)
---
### В чем разница между процессами и потоками?
* **Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы** (например, процессорное время и память). **Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого.**  Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.  Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.  
* **Поток**(thread) — **способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах.** Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.

### Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable?
Thread - это класс, некоторая надстройка над физическим потоком. Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей. Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком. В классе Thread имеется несколько методов, которые можно переопределить в порожденном классе. Из них обязательному переопределению подлежит только метод run(). Этот же метод, безусловно, должен быть определен и при реализации интерфейса Runnable. Некоторые программисты считают, что создавать подкласс, порожденный от класса Thread, следует только в том случае, если нужно дополнить его новыми функциями. Так, если переопределять любые другие методы из класса Thread не нужно, то можно ограничиться только реализацией интерфейса Runnable. Кроме того, реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс, отличающийся от Thread

### Чем Runnable отличается от Callable?
Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();  
Метод Runnable.run() не возвращает никакого значения,  
Callable - это параметризованный функциональный интерфейс. Callable.call() возвращает Object, если он не параметризован, иначе указанный тип.  
Метод run() НЕ может выбрасывать проверяемые исключения, в то время как метод call() может.

### Какими двумя способами можно создать поток?
* Реализуя интерфейс Runnable или Callable
* Расширяя класс Thread

### Какой способ создания потоков предпочтителен?
Предпочтительнее через имплементацию интерфейса, т.к. при расширении через класс Thread пропадает возможнсоть унаследовать свой класс от другого класса.

### Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?
Потоки-демоны **работают в фоновом режиме вместе с программой**, но не являются неотъемлемой частью программы. **Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения**, то такой процесс может быть запущен как поток-демон с помощью метода `setDaemon(boolean value)`, вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. **Основной поток приложения может завершить выполнение потока-демона** (в отличие от обычных потоков) **с окончанием кода метода main(), не обращая внимания, что поток-демон еще работает.**  
Поток демон можно сделать только если он еще не запущен. Пример демона - GC.

### В каких состояниях может находиться поток?
* **New** - объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется.  
* **Runnable** - поток готов к выполнению, но планировщик еще не выбрал его.  
* **Running** – поток выполняется.  
* **Waiting/blocked/sleeping** - поток блокирован или поток ждет окончания работы другого потока.Dead - поток завершен. Будет выброшено исключение при попытке вызвать метод start() для dead потока. 
У класса Thread есть внутренний класс State - состояние, а также метод public State getState().
```java
public enum State (){
	NEW, // поток создан, но еще не запущен; 
	RUNNABLE, // поток выполняется; 
	BLOCKED, // поток блокирован; 
	WAITING, // поток ждет окончания работы другого потока; 
	TIMED_WAITING, // поток некоторое время ждет окончания другого потока; 
	TERMINATED; // поток завершен.  
}
```

### Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?
Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета(является ли поток демоном).  
Чтобы установить приоритет потока, используется метод класса Thread: `final void setPriority(int level)`. Значение level изменяется в пределах от `Thread.MIN_PRIORITY = 1` до `Thread.MAX_PRIORITY = 10`. Приоритет по умолчанию - **Thread.NORM_PRlORITY = 5.**  
Получить текущее значение приоритета потока можно вызвав метод: `final int getPriority()` у экземпляра класса Thread.  
Метод yield() можно использовать для того чтобы принудить планировщик выполнить другой поток, который ожидает своей очереди.

### Как работает Thread.join()? Для чего он нужен?
Когда поток вызывает join(), он будет ждать пока поток, к которому он присоединяется, будет завершён, либо отработает переданное время:  
```java
void join()   
void join(long millis) // с временем ожидания  
void join(long millis, int nanos)  
```
Применение: при распараллелили вычисления, вам надо дождаться результатов, чтобы собрать их в кучу и продолжить выполнение.

### Что такое race condition?
Состояние гонки (race condition) - о**шибка проектирования многопоточной системы или приложения, при которой работа зависит от того, в каком порядке выполняются потоки**. Состояние гонки в**озникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток**: поведение кода изменяется, из-за чего возникают недетерменированные ошибки.  
* **DataRace** - это свойство выполнения программы. Согласно JMM, выполнение считается содержащим гонку данных, если оно содержит по крайней мере два конфликтующих доступа (чтение или запись в одну и ту же переменную), которые не упорядочены отношениями «happens before».  
* **Starvation** - потоки не заблокированы, но есть нехватка ресурсов из-за чего потоки ничего не делают.    
  Самый простой способ решения — копирование переменной в локальную переменную. Или просто синхронизация потоков методами и sync-блоками.

### Что такое Фреймворк fork/join? Для чего он нужен?
Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. **Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.**  
**Этап Fork**: **большая задача разделяется** на **несколько меньших подзадач,** которые в свою очередь также разбиваются на меньшие. **И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.**  
**Этап Join:** далее (опционально) идёт процесс «свёртки» - **решения подзадач некоторым образом объединяются пока не получится решение всей задачи.**  
Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.  
Для **решения** **некоторых** задач **этап Join не требуется. Например**, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.  
Ещё одно **преимущество** этого фреймворка заключается в том, что он **использует work-stealing алгоритм**: **потоки**, которые **завершили** выполнение **собственных подзадач**, могут «**украсть**» **подзадачи** **у** других **потоков**, **которые** **всё ещё заняты.**

### Java Memory Model
**Описывает как потоки должны взаимнодействовать через общую память.** Определяет набор действий межпоточного взаимодействия. В частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока.  
**JMM определяет отношение между этими действиями "happens-before" - абстракцей обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.**
Можно выделить несколько основных областей, имеющих отношение к модели памяти:  
**Видимость** (visibility). **Один поток может временно сохранить значения некоторых полей не в основную память, а в регистры или локальный кэш процессора,** таким образом второй поток, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.  
К вопросу видимости имеют отношение следующие ключевые слов языка Java: synchronized, volatile, final.

С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в heap памяти, которая доступна всем потокам. Кроме этого, каждый поток имеет локальную—рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями.

* **synchronized** **- При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную.** Такое поведение synchronized методов и блоков следует из правил для отношения «происходит раньше»
* **volatile** **- запись volatile-переменных производится в основную память, минуя локальную. и чтение volatile переменной производится также из основной памяти**, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение.
* **final -** после того как объект был корректно создан, **любой поток может видеть значения его final полей без дополнительной синхронизации**. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. Рекомендуется изменять final поля объекта только внутри конструктора, в противном случае поведение не специфицировано.

**Переупорядочивание** (Reordering). Для увеличения производительности процессор/компилятор **могут переставлять местами некоторые инструкции/операции.** **Процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее**. Эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью.  
Также регулируется набором правил «happens-before»: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных.
