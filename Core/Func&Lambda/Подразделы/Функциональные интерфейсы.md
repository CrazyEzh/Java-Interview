---
up: [[Функциональные интерфейсы и лямбда-выражения]]
---
# Функциональные интерфейсы
---
### Что такое функциональный интерфейс?
Это интерфейс, который содержит только 1 абстрактный метод.  
Интерфейс может включать сколько угодно default (и static) методов и при этом оставаться функциональным, потому что default методы - не абстрактные.

### Какие встроенные функциональные интерфейсы вы знаете?
```java      
Predicate<T> // реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean  
Consumer<T> //реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает    
Function<T,R> //реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R    
Supplier<T> //реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T     
UnaryOperator<T> //принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T     
BinaryOperator<T, Т> //реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T
```

### Где находятся функциональные интерфейсы?
В пакете `java.util.function;` (несколько десятков интерфейсов)

### Перечислить основные семейства функ.интерфейсов?
Несколько десятков интерфейсов делятся на 5 семейств.
* **Consumer (потребители)** - это те кто принимают какое то значение , но ничего не возвращают взамен. В параметрах у консумеров дженерик \<T\>, дженерики не могут принимать примитивы, поэтому разработчики добавили отдельные консумеры, принимающие примитивы IntC, LongC, DoubleC. Также есть консумеры , принимающие по 2 параметра, например BiConsumer<T,U> и соответственно его метод void accept(T,U) также принимает 2 параметра.  
* **Supplier** - они не принимают ничего в качестве параметра, а просто возвращают какое то значение.(также есть отдельные для Булеан, лонг, инт)  
* **Predicate** - их функциональный метод принимает значение какого- то типа, а наружу отдаёт булевское значение(true\false) (также есть отдельные предикаты для лонг, инт, дабл, а также предикат принимающий сразу 2 параметра BiPredicate).  
*  **Function** - функция принимает аргумент и возвращает значение какого то типа. (в общем случае это разные типы) Function <T,R> , где T это входящий тип, а R это возвращаемый тип. есть как и во всех семействах есть ее разновидности работающие с примитивами например LongToIntF(принимает long, возвращает int)  
* **Operator** - это частный случай функции , когда на входе и на выходе значения одного и того же типа. Унарный оператор принимает один параметр UnaryOperator\<T\>, а бинарный BinaryOperator - 2. И отдельные интерфейсы над примитивами int, long, double.

### Все способы реализации функционального интерфейса?
Функциональные интерфейсы можно инстанцировать 4мя способами:  
  
* Реализовать обычный или анонимный класс, реализующий интерфейс, но это громоздко, а если данный класс не будет переиспользоваться, то и излишне  
* Использовать лямбда - выражение . Компилятор знает ожидаемый интерфейс и поэтому не требует от программиста повторять имя этого интерфейса, а также имя метода , типы параметров и типо возвращаемого значения справа от знака равенства. Просто объявляются имена параметров потом стрелочка направо и тело метода(непосредственно исполняемый код)  
* Можно использовать ссылку на метод . Например мы можем ссылаться на статический метод вот так например: `Integer :: parseInt;` Или мы можем ссылаться на нестатический метод, указывая конкретный объект два двоеточия и имя нестатического метода вот так: `System.out:: println;` Ещё один способ вызвать нестатический метод `Function<Object, String> objectToString = Object :: toString` (но тогда первый передаваемый в месте вызова функционального интерфейса параметр будет тем самым объектом, на котором данный нестатический метод будет вызван).  
* А ещё можно ссылаться на конструктор тогда пишут имя класса, 2 двоеточия и ключевое слово new: `Sring[] :: new`;

### Для чего нужна аннотация @FunctionalInterface?
Нужна чтобы точно определить интерфейс как функциональный. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.

### Как взаимосвязаны лямбда и функциональный интерфейс?
**Лямбда-выражение** или просто лямбда в Java — упрощённая запись анонимного класса, реализующего функциональный интерфейс.  
Цель лямбда-выражения состоит в том, чтобы иметь возможность создать экземпляр функционального интерфейса, реализуя единственную функцию функционального интерфейса. то есть. разрешить создание экземпляра с единственной функцией.

### Зачем нужны default методы в функциональном интерфейсе
Для обратной совместимости.  
Если у вас есть интерфейс, который другие люди внедрили, то если вы добавите новый метод в интерфейс, все существующие реализации будут нарушены.  
Добавив новый метод с реализацией по умолчанию, вы остаетесь совместимым с исходным кодом с существующими реализациями.

### Сколько дефолтных методов и статических методов, статических полей в интерфейсе?
В функциональном интерфейсе может быть сколько угодно дефолтных методов, статических методов и статических полей.

### Отличие BinaryOperator от Function
 В целом - функцио. интерфейсы семейства Operator - это частные случаи Function. Различие между ними в том, что function может принять объект одного типа , а вернуть другого, а operator принимает и возвращает один и тот же тип.  
  
Java 8 BinaryOperator - это функциональный интерфейс, расширяющий BiFunction. BinaryOperator принимает два аргумента одного типа и возвращает результат того же типа своих аргументов. 
```java
@FunctionalInterface  
public interface BinaryOperator<T> extends BiFunction<T,T,T> {  
}  
  
//The BiFunction takes two arguments of any type, and returns a result of any type  
  
@FunctionalInterface  
public interface BiFunction<T, U, R> {  
R apply(T t, U u);  
}
```  