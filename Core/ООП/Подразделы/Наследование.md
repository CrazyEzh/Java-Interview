---
up: [[ООП]]
---
# Наследование
---
### Какие существуют типы наследования?
Java поддерживает четыре типа наследования:

* **Одиночное наследование**: при одиночном наследовании один класс наследует свойства другого, то есть будет только один родительский и один дочерний класс.
* **Многоуровневое наследование**: когда класс является производным от класса, который также является производным от другого класса, то есть класса, имеющего более одного родительского класса, но на разных уровнях, такой тип наследования называется многоуровневым наследованием.
* **Иерархическое наследование**: когда класс имеет несколько дочерних классов (подклассов) или, другими словами, несколько дочерних классов имеют один и тот же родительский класс, тогда такой вид наследования называется иерархическим.
* **Гибридное наследование**. Гибридное наследование – это комбинация двух или более типов наследования.

### Как проблема ромбовидного наследования решена в Java?
**В Java нет поддержки множественного наследования классов.**  
  
Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.  
  
1. **Классы всегда побеждают**: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.  
2. Если не срабатывает правило 1, то **побеждают саб-интерфейсы (more specific)**. Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.  
3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен **явно через super определить**, какой именно метод вызвать, иначе компилятор будет сильно материться.

### Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
Класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать:  
```java
InterfaceB.super.method();
```

### В чем разница между this и super?
`super` и `this` являются специальными ключевыми словами, которые используются для обращения к полям и методам текущего или родительского класса.
`this` указывает на текущий объект а `super` указывает на родительский класс данного объекта.