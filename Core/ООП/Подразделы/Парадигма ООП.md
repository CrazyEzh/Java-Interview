---
up: [[ООП]]
---
# Парадигма ООП
---
### Что такое ООП
**ООП** - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.  
  
Согласно парадигмы ООП программа состоит из обьектов, обменивающихся сообщениями. Обьекты могут обладать состоянием, единственный способ изменить состояние обьекта - передать ему сообщение, в ответ на которое, обьект может изменить собственное состояние.  
  
**Класс** — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.

### Назовите основные принципы ООП
**Инкапсуляция  
Наследование  
Полиморфизм**
Иногда к ним причисляют **Абстракцию**

### Какие преимущества у ООП
**Легко читается** - не нужно выискивать в коде функции и выяснять, за что они отвечают
**Быстро пишется** - можно быстро создать сущности, с которыми должна работать программа.
**Простота реализации большого функционала** - т.к. на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей
**Меньше повторений кода** - не нужно писать однотипные функции для разных сущностей

### Какие недостатки у ООП
**Потребление памяти** - обьекты потребляют больше оперативной памяти, чем примитивные типы данных
**Снижает производительность** - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.
**Неэффективность и неэкономное распределения памяти на этапе выполнения** (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).
**Излишняя универсальность**. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.
**Сложно начать** - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени

### Что такое наследование? С примером
Свойство системы, которое позволяет описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.
```java
class Animal{
	public void run(){
		System.out.println("Animal running");
	}
}
class Cat extends Animal{
	private String name;
}
Cat cat = new Cat();
cat.run(); //Animal running 
```

### Что такое инкапсуляция? С примером
**Инкапсуляция** - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»).  
Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.
Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. 

```java
class Cat extends Animal{
	private String name;
	public String getName(){
		return this.name;
	}
	public void setName(String name){
		//при желаниии можно добавить проверки для входных данных
		this.name = name;
	}
}
```

### Что такое полиморфизм? С примером
**Полиморфизм** – предоставляет возможность единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса.  
Есть три вида полиморфизма:  
* ad hoc полиморфизм, основан на различении типов. Для различных типов аргументов используется разный код метода, пример статического - перегрузка метода. Пример динамического - переопределение метода.  
* параметрический полиморфизм - ситуация, когда один и тот же метод работает с аргументами различных типов одинаково, не зависимо от их точного типа. Пример — функция, работающая с объектом некоторого класса C, может без изменений работать с объектом порождённого от C класса (этот вид полиморфизма часто называют полиморфизм включения).  
* subtype полиморфизм - самый популярный - возможность объектов с одинаковой спецификацией(интерфейс\класс\abstract класс) иметь различную реализацию.  
  
*Пример:*  
Переопределение методов, интерфейсы.

### Что такое ассоциация
**Ассоциация** - обозначает связь между обьектами. Например, игрок играет в определенной команде.

Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.

### Что такое агрегация
Агрегация является особой формой ассоциации. Это более конкретизированные отношения между объектами.  
Агрегация — отношение когда один объект является частью другого.  
Например: Студент входит в Группу любителей физики.Это представляет отношения HAS-A.  
  
Агрегация определяет отношение HAS A ("имеет"), но связь слабее, чем в композиции, т.к. обьекты будут равноправны.

### Что такое композиция
**Композиция** — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже.  
  
Например, в класс автомобиля содержит объект класса электрического двигателя:
```java
public class ElectricEngine{

}
public class Car {  
	ElectricEngine engine; 
	public Car(){ 
		engine = new ElectricEngine();  
	}
}
```
При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.

### Что такое абстракция?
**Абстракция** относится к качеству работы с идеями, а не с событиями. В основном он занимается сокрытием деталей и показом пользователю важных вещей. Таким образом, можно сказать, что абстракция – это процесс сокрытия деталей реализации от пользователя и раскрытия им только функциональных возможностей. Абстракции можно достичь двумя способами:
* Абстрактные классы (можно достичь 0-100% абстракции).
* Интерфейсы (можно достичь 100% абстракции).

### Расскажите про раннее и позднее связывание
Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен.  
  
**Раннее связывание**  
Если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием. Используется для final, перегруженных, статических методов.  
**Позднее связывание (late binding)** - вызов метода возможен только во время выполнения, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии. Используется для переопределенных и абстрактных методов. Вот пример: Object a = ... // какое-то присваивание a.toString(); На этапе компиляции мы не знаем, какого типа объект a. Он может быть как собственно Object, так и любым его наследником, в котором метод toString() переопределён. Именно на этапе выполнения определяется тип a и вызывается toString() из того класса, какого типа объект a. Это и есть позднее связывание.  
 
В случае статического связывания используются не конкретные объекты, а информация о типе, то есть используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.  
  
Исходя из того, что раннее связывание выполняется на этапе компиляции, а позднее - в рантайме, первый вариант обладает лучшим быстродействием, однако второй необходим для реализации полиморфизма.

### Что такое множественное наследование? Поддерживается ли это Java?
Если дочерний класс наследует свойство от нескольких классов, это называется множественным наследованием. Java не позволяет расширять несколько классов.

Проблема с множественным наследованием заключается в том, что если несколько родительских классов имеют одно и то же имя метода, то во время выполнения компилятору становится сложно решить, какой метод выполнять из дочернего класса.

> Следовательно, Java не поддерживает множественное наследование. Проблема обычно называется проблемой бриллианта.