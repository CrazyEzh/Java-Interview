---
up: [[ООП]]
---
# Методы
---
### Различия статических и нестатических методов
Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.

### Можно ли использовать статические методы в обычных? Наоборот? Почему?
На прямую у статического метода нет возможности вызвать нестатический метод класса, поскольку для вызова нестатического метода необходим объект. Если внутри статического метода создать объект класса то у этого объекта можно быдует вызывать нестатические методы.
Наоборот можно поскольку статические методы не нуждаются в ссылке на экземпляр, они могут быть вызваны из обоих контекстов. Только методы экземпляра имеют ограничение на вызов объекта, поскольку они неявно принимают объект в качестве дополнительного аргумента.

### Можно ли получить доступ к нестатическому полю из статического метода?
Нет, поскольку нестатические поля и методы являются частью объекта, а не класса. У статического метода есть доступ только к статическим полям.

### Можно ли создавать абстрактные методы в обычном классе? Создавать обычное методы в абстрактном классе?
В обычном классе без объявления его абстрактным нельзя создать абстрактные методы. Возникнет ошибка компиляции. ПРи этом абстрактные классы могут содержать обычные методы.


### Что такое перегрузка метода и переопределение метода?
Перегрузка метода:
* При перегрузке методов методы одного класса имеют одно и то же имя, но каждый метод должен иметь разное количество параметров или параметров, имеющих разные типы и порядок.
* Перегрузка метода – это возможность добавить или расширить поведение метода.
* Это полиморфизм времени компиляции.
* У методов должна быть другая сигнатура.
* Может потребоваться или не потребоваться наследование в перегрузке метода.
Давайте посмотрим на пример ниже, чтобы лучше понять это.
```java
Class Adder {
	static int add(int a, int b)	{
		return a+b;
	}
	static double add(double a, double b){
		return a+b;
	}
	public static void main(String args[]){
		System.out.println(Adder.add(11,11));
		System.out.println(Adder.add(12.3,12.6));
	}
}
```

Переопределение метода:

* При переопределении метода подкласс имеет тот же метод с тем же именем, точно такое же количество и тип параметров и тот же тип возвращаемого значения, что и суперкласс.
* Переопределение метода заключается в «изменении» существующего поведения метода.
* Это полиморфизм времени выполнения.
* Методы должны иметь одинаковую сигнатуру.
* Это всегда требует наследования в переопределении метода.
Давайте посмотрим на пример ниже, чтобы лучше понять это.
```java
Class Car {
	void run(){
		System.out.println(“car is running”);
	}
}
Class Audi extends Car{
	void run(){
		System.out.prinltn("Audi is running safely with 100km");
	}
	public static void main( String args[])	{
		Car b=new Audi();
		b.run();
	}
}
```

### Что можно делать при переопределении метода, а что нельзя?
При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.
Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить overloading (перегрузка) метода.
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

### Для чего нужна аннотация Overide?
Чтобы указать компилятору на необходимость проверки сигнатур методов в суперклассе и подклассе
Переопределенный метод принято снабжать аннотацией @Override. Ее отсутствие допускается, но компиляция не перегружающего метода с такой аннотацией приведет к ошибке.
Компилятор, когда встретит данную аннотацию, проверит, чтоб сигнатуры методов в супер классе и в под классе совпадали, т.е. вы переопределили метод, и в полиморфизме будит вызываться переопределенный метод.
Если вдруг вы ошиблись в сигнатуре метода (например пропустили букву в названии), то компилятор выдаст ошибку

### Может ли статический метод быть переопределён или перегружен?
**Нельзя переопределять статические методы.**  
Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса вместо переопределения. Это явление известно как **сокрытие методов** (hiding methods).**Перегружен - да**. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.

### Могут ли нестатические методы перегрузить статические?
Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.

### Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?
**В сигнатуре(имя + параметры) менять ничего нельзя.**  
  
* Возможно расширение уровня доступа.  
* Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
* Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

### Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
При переопределении метода **нельзя сузить модификатор доступа** к методу (например, с public до private), но можно расширить.  
**Изменить тип возвращаемого значения нельзя, но можно сузить** возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.

### Ковариантность типа возвращаемого значения?
В JDK 5 появилась концепция ковариантности возвращаемых типов; этот термин означает, что переопределенный метод производного класса может вер­нуть тип, производный от типа, возвращаемого методом базового класса.
При переопределении методов (overriding) сигнатуры методов должны совпадать. В сигнатуру методов входит имя метода и его параметры. Возвращаемые параметры, туда не входят. За одним исключением, а именно метод в котором делается переопределение, может возвращать не только сам объект, но и его потомков. именно это и называется страшным словом ковариантность.
```java
public class Main {
	public static void main(String[] args) {
		Employee [] managers = new Employee [6];

		managers[0] = new Employee( new Dude() );
		managers[1] = new Employee( new Boy() );
		managers[2] = new Employee( new Girl() );

		managers[3] = new Manager( new Dude() );
		managers[4] = new Manager( new Boy() );
		managers[5] = new Manager( new Girl() );                

		for (Employee m : managers){
				System.out.println(""Sex: "" + m.getPerson() );
		}
	}
}

class Manager extends Employee{
	Manager(Person person){
		super(person);
	}
	@Override
	public Dude getPerson(){
		System.out.print(""Manager.getPerson() --> "");
		return (Dude) person;
	}
}

class Employee {
	protected Person person;
	Employee(Person person){
		this.person = person;
	}

	public Person getPerson(){
		System.out.print(""Employee.getPerson() --> "");
		return person;
	}
}

abstract class Person {
	protected String sex="";
	@Override
	public abstract String toString();
}

class Dude extends Person{
	protected String sex = ""asexual"";

	@Override
	public String toString() {
		return sex;
	}
}

class Boy extends Dude {
	protected String sex = ""male"";

	@Override
	public String toString() {
		return sex;
	}
}

class Girl extends Dude
{
	protected String sex = ""female"";

	@Override
	public String toString() {
		return sex;
	}

}
```
Результат:
```java
Employee.getPerson()  // Sex: asexual
Employee.getPerson()  // Sex: male
Employee.getPerson()  // Sex: female
Manager.getPerson()   // Sex: asexual
Manager.getPerson()   // Sex: male
Manager.getPerson()   // Sex: female
```

Как видим в классе Employee, метод getPerson возвращает тип Person. А в наследнике Employee, классе Manager, в переопределенном методе, мы возвращаем уже класс Dude. В выводе мы вывели название вызываемых классов, поэтому видим что переопределение работает.

Вывод: При переопределении (overriding) сигнатуры методов должны совпадать. Возвращаемый тип должен либо совпадать, либо быть потомком первоначально выбранного объекта (ковариантные типы).