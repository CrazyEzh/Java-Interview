---
up: [[Общие вопросы]]
---
# Прочее
---
### Логические операторы
Когда в выражении несколько логических операторов, результат вычисляется с учётом их приоритета. Если нет логических скобок, то операции выполняются в таком порядке:
**! (NOT)
& (AND)
^ (XOR)
| (OR)
&& (условный AND)
|| (условный OR)**
[Подробнее на JavaRush](https://javarush.ru/groups/posts/logicheskie-operacii-v-java)

### Отличие операторов сокращенных логических операторов и полных
`&&` и `||` называются сокращёнными логическими операторами AND и OR соответственно, или операторами короткой схемы вычислений. В спецификации Java их ещё зовут условными
Разница в том, что для операторов `&` и `|` всегда вычисляются значения обоих операндов, а при работе операторов `&&` и `||` второй операнд вычисляется только по необходимости.

### Что такое рекурсия? Недостатки и преимущества? 2 случая (правила/условия) в рекурсивном алгоритме?
**Рекурсия** – это вызов функции самой себя для перехода к следующему шагу рекурсии. Чтобы следующий шаг рекурсии отличался от предыдущего, значение как минимум одного из параметров функции должно изменяться в процессе рекурсивного вызова.
Можно выделить следующие взаимосвязанные преимущества рекурсии:
* естественность (натуральность) выражения сложных, на первый взгляд, алгоритмов.
* рекурсивный алгоритм более читабелен в сравнении с итерационным;
для многих распространенных задач рекурсию более легче реализовать чем итерацию. Рекурсия хорошо подходит для реализации алгоритмов обхода списков, деревьев, графов и т.д.

Недостатки рекурсии состоят в следующем:

по сравнению с итерацией многократный вызов рекурсивной функции работает дольше. Это связано с тем, что при вызове рекурсивного метода его параметры копируются в стек. Также запоминаются временные значения локальных внутренних переменных. При завершении вызова рекурсивной функции предыдущие значения параметров вытягиваются из стека, что приводит к лишним операциям. Итерационный алгоритм для такой же задачи работает быстрее;
для рекурсивного процесса нужно больше памяти чем для итерации. Это связано с тем, что при рекурсивном вызове нужно сохранять предыдущее значение внутренних переменных вызывающей функции, чтобы по завершении рекурсивного вызова восстановить ее выполнение. Таким образом, если рекурсивная функция вызывается много раз, то это может привести к чрезмерно большому использованию памяти.

<iframe width="760" height="427" src="https://www.youtube.com/embed/9Hs7DuIJ3LE?controls=0"  frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### SOLID
**SOLID** — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования.

**S(Single Responsibility Principle)** - принцип единственной ответственности - каждый класс выполняет лишь одну задачу.  
Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.  
**O(Open Closed Principle)** - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации.  
Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.  
**L(Liskov’s Substitution Principle)** - принцип подстановки барбары лисков - объекты в программе можно заменить их наследниками без изменения свойств программы.  
**I(Interface Segregation Principle)** - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий  
**D(Dependency Inversion Principle)** - принцип инверсии зависимостей - зависимость на абстракциях.  
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.  
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.  
  
Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) и разные карты оплаты.