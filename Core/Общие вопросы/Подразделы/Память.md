---
up: [[Общие вопросы]]
---
# Память
---
### В какой области памяти хранятся примитивы?
Примитивы в Java хранятся в стеке (**Stack**)

### В какой области памяти хранятся ссылки на объект?
Ссылки на объект в Java так же хранятся в стеке (**Stack**)

### В какой области памяти хранятся объекты?
Объекты в Java хранятся в куче (**Heap**)

### Виды ссылок в Java
1. **StrongReference** - это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.
```java
StringBuilder builder = new StringBuilder();
```
 `builder` это и есть strong-ссылка на объект `StringBuilder`.
2. **SoftReference** —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит `OutOfMemoryError`. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.
```java
StringBuilder builder = new StringBuilder();
SoftReference<StringBuilder> softBuilder = new SoftReference(builder);
```
`softBuilder.get()` — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется `null`.
`softBuilder.clear()` — удалит ссылку на объект StringBuilder
То же самое работает для WeakReference.
3. **WeakReference** — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong-ссылки), то он удалит его из памяти.
4. **PhantomReference** — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.
Особенностей у этого типа ссылок две.
Первая это то, что метод `get()` всегда возвращает `null`. Именно из-за этого PhantomReference имеет смысл использовать только вместе с ReferenceQueue.
Вторая особенность – в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue после того как выполниться метод finalize().
**ReferenceQueue** позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании Reference мы можем передать в конструктор ReferenceQueue, в который будут помещаться ссылки после удаления.


### В чем разница между кучей и стековой памятью?
Характеристики	| Stack |	Heap
----------------|-------|---------
**Объем памяти**	|  Память стека используется только одним потоком выполнения. | Память кучи используется всеми частями приложения. 
**Доступ** |	Другие потоки не могут получить доступ к памяти стека. |	Объекты, хранящиеся в куче, доступны глобально. |
**Управление памятью** |	Для освобождения памяти следует метод LIFO. |	Управление памятью основано на генерации, связанной с каждым объектом.
**Продолжительность жизни** |	Существует до конца выполнения потока. |	Память в куче живет от начала до конца выполнения приложения.
**Использование** |	Память стека содержит только локальные примитивы и ссылочные переменные для объектов в пространстве кучи. |	Всякий раз, когда объект создается, он всегда сохраняется в пространстве кучи.

### Что такое сборщик мусора? (Garbage collector)
Сборщик мусора выполняет две задачи:
* поиск мусора;
* очистка мусора.

Для обнаружения мусора есть два подхода:
* **Учет ссылок (Reference counting);**
* **Трассировка (Tracing). (используется в HotSpot)6**

Процессы сборки мусора разделяются несколько видов:
**minor GC (малая)** - частый и быстрый, работает только с областью памяти "young generation"
* приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world)
* «живые» объекты из Eden перемещаются в область памяти «To»
* «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»
* Eden и «From» очищаются от мусора
* «To» и «From» меняются местами
* приложение возобновляет работу

**major GC (старшая)** - редкий и более длительный, затрагивает объекты старшего поколения.
В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.
**full GC (полная)** -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).

### Какие существуют типы сборщиков мусора в Java?
Существует четыре типа:
* Серийный сборщик мусора.
* Параллельный сборщик мусора.
* Сборщик мусора CMS.
* Сборщик мусора G1.

[Подробнее на Habr.com](https://habr.com/ru/post/269621/)