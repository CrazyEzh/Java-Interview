---
up: [[Общие вопросы]]
---
# Нововведения Java8
---
### Какие нововведения появились в Java 8?
1. Полноценная поддержка лямбда-вражений  
2. Ссылки на методы ::  
3. Функциональные интерфейсы  
4. default методы в интефейсах  
5. Потоки для работы с коллекциями  
6. Новое api для работы с датами  
7. Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.  
8. Кодировщик/декодировщик.  
9. Новые методы для Map - PutIfAbsent(), СomputeIfAbsent()\СomputeIfPresent(), Remove(), GetOrDefault(), Merge()  
10. Metaspace пришла на замену PermGen

### Какие новые классы для работы с датами появились в Java 8?
```java
LocalDate , LocalTime, LocalDateTime, ZonedDateTime, Period, Duration
```


### Расскажите про класс Optional
`Optional` - новый класс в пакете `java.util`, является контейнером (оберткой) для значений которая также может безопасно содержать `null`. Благодаря опциональным типам можно забыть про проверки на `null` и `NullPointerException`.

### Что такое Nashorn?
В Java 8, Nashorn, представлен значительно улучшенный движок javascript для замены существующего Rhino. Nashorn обеспечивает в 2-10 раз лучшую производительность, так как он напрямую компилирует код в памяти и передает байт-код в JVM. Nashorn использует функцию динамического вызова, представленную в Java 7, для повышения производительности.  
* **Nashorn** — немецкое слово (Носорог)

### Что такое JJS?
Инструмент командной строки для выполнения JavaScript-кодов на консоли.

### Какой класс появился в Java 8 для кодирования/декодирования данных?
```java
public static class Base64.Encoder
public static class Base64.Decoder
```

### Как создать Base64 кодировщик и декодировщик?
Используя метод `getDecoder()` класса `Base64` он возвращает декодировщик `Base64.Decoder`, который декодирует данные с помощью схемы кодирования base64.

### Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?
* `putIfAbsent()` добавляет пару «ключ-значение», только если ключ отсутствовал:  
```java
map.putIfAbsent("a", "Aa");
```

* `forEach()` принимает функцию, которая производит операцию над каждым элементом:
```java
map.forEach((k, v) -> System.out.println(v));
```

* `compute()` создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):  
```java
map.compute("a", (k, v) -> String.valueOf(k).concat(v)); //["a", "aAa"]
```

* `computeIfPresent()` если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):  
```java
map.computeIfPresent("a", (k, v) -> k.concat(v));  
```

* `computeIfAbsent()` если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):  
```java
map.computeIfAbsent("a", k -> "A".concat(k)); //["a","Aa"]  
```

* `getOrDefault()` в случае отсутствия ключа, возвращает переданное значение по-умолчанию:  
```java
map.getOrDefault("a", "not found");  
```

* `merge()` принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.  
  
* `map.remove(key, value)` - Если такое ключ-значение есть в map, то удаляем

### Что такое LocalDateTime?
`LocalDateTime` объединяет вместе `LocaleDate` и `LocalTime`, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как `plusMinutes, plusHours, isAfter, toSecondOfDay` и т.д.

### Что такое ZonedDateTime?
`java.time.ZonedDateTime` — аналог `java.util.Calendar`, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает объект ZoneId - временную зону(в ZoneId 599 зон), поэтому все операции с временными сдвигами этот класс проводит с её учётом.