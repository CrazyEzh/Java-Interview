---
up: [[Общие вопросы]]
---
# Примитивы
---
### Какие примитивные типы данных есть в Java?
Вещественные, целочисленные, логические и строковые.  
```java
byte  
short  
int  
long  
float  
double  
char  
boolean
```

### Размерность примитивных типов
Целочисленные типы

Тип | Размер (бит) | Диапазон
----|:------------:|---------
byte | 8 бит | от -128 до 127
short | 16 бит | от -32768 до 32767
char | 16 бит | беззнаковое целое число, представляющее собой символ UTF-16
int | 32 бит | от -2147483648 до 2147483647
long | 64 бит | от -9223372036854775808L до 9223372036854775807L

Типы с плавающей точкой

Тип | Размер (бит) | Диапазон
----|:------------:|---------
float | 32 бит | от 1.4e-45f до 3.4e+38f
double | 64 бит | от 4.9e-324 до 1.7e+308

Логический тип

Тип | Размер (бит) | Значение
----|:------------:|---------
boolean | 8 бит или 32 бит | true (истина) или false (ложь)

В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версиях JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.


### Какими значениями инициируются переменные по умолчанию?
```java
byte = 0  
short = 0  
int = 0  
long = 0L  
float = 0.0f  
double = 0.0d  
char = '\u0000'  
boolean = false  
Object = null
```

Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса.  
Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.

### Что такое char?
**16-разрядное беззнаковое целое**, представляющее собой символ UTF-16 (буквы и цифры)

### Почему над char можно выполнять арифметические операции?
Тип `char` хотя и предназначен для представления отдельных символов Unicode, все же является целочисленным типом. Поэтому над ним возможны все те же самые операции, что и над другими целочисленными типами.

### Размер примитивного типа boolean в разных ситуациях и в массиве типов boolean
**Зависит от реализации JVM**  
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.

### Что такое классы-обертки?
**Обертка** — это специальный класс, который хранит внутри себя значение примитива(объекты классов-оберток являются неизменяемыми (Immutable)). Каждому примитивному типу данных посвящен свой класс-обертка.
Обертки нужны для реализации дженериков, поскольку дженерики не работают с примитивными типами

### Что такое автоупаковка и автораспаковка?
**Автоупаковка** - присвоение классу обертки значения примитивного типа;  
  
**Автораспаковка** - присвоение переменной примитивного типа значение класса обертки.  
  
Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.  

### Что такое пул интов?
В Java есть пул(pool) целых чисел в промежутке \[-128;127\], так как это самый часто вречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.  
Изменить размер кэша в HotSpot вы можете, указав ключ `-XX:AutoBoxCacheMax=<размер>`.

### Что такое NaN?
**"NaN" означает "not a number"**. "Nan" создается, если операция с плавающей запятой имеет некоторые входные параметры , которые приводят к получению некоторого неопределенного результата. Например, 0.0, деленное на 0.0, арифметически не определено. Взятие квадратного корня из отрицательного числа также не определено.

### [[Приведение типов]]
![[Приведение типов#Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?]]

![[Приведение типов#Какие данные мы рискуем потерять при привидении char в short?]]

![[Приведение типов#Какие данные мы рискуем потерять при явных при ведениях]]

![[Приведение типов#При сложении char short какой результирующий тип получим]]

![[Приведение типов#Можно ли положить максимальное значение long во float]]

![[Приведение типов#byte a = 1; byte b = 2; byte c = a + b; Будут ли какие-то проблемы?]]
