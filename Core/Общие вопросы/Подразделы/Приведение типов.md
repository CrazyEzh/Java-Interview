---
up: [[Примитивы]]
---
# Приведение типов
---

### Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?
**Неявное приведение** – автоматическое расширение типа переменной от меньшего к большему.  
  
**Явное приведение** - явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.  
  
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим `ClassCastException`.

### Какие данные мы рискуем потерять при привидении char в short?
`char` 16 бит от 0 до 64 000+ , а у `short` от -32000 до + 32 000. Соответственно половина значений char не укладывается в диапазон

### Какие данные мы рискуем потерять при явных при ведениях?
Приведение примитивных типов чаще всего используют для преобразования значений с плавающей точкой в целые числа. При этом дробная часть значения с плавающей точкой просто отбрасывается (то есть значение с плавающей точкой округляется по направлению к нулю, а не к ближайшему целому числу). По существу берется только целочисленная часть вещественного типа и она уже приводится к целевому типу целочисленного числа.

При приведении более емкого целого типа к менее емкому старшие биты просто отбрасываются. По существу это равнозначно операции деления по модулю приводимого значения на диапазон целевого типа (например для типа byte это 256).

Слишком большое дробное число при приведении к целому превращается в MAX_VALUE или MIN_VALUE.

Слишком большой double при приведении к float превращается в Float.POSITIVE_INFINITY или Float.NEGATIVE_INFINITY.

<iframe width="760" height="427" src="https://www.youtube.com/embed/bHWDG9bfDRg?controls=0"  frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### При сложении char short какой результирующий тип получим
При сложении любых целочисленных типов результирующим типом будет `int`

### Можно ли положить максимальное значение long во float
Да, это возможно по той причине, что float имеет слишком мало (обычно 6-7) значащих цифр, чтобы иметь дело со всеми возможными числами, которые может представлять long (19 значащих цифр).

### byte a = 1; byte b = 2; byte c = a + b; Будут ли какие-то проблемы?
Да, потому что результатом сложения будет тип int и компилятор автоматически не может сохранить тип int в байт. Нужно явное приведение типов