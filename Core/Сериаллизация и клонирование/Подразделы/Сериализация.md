---
up: [[Сериализация и клонирование]]
---
# Сериализация
---
### Что такое сериализация и как она реализована в Java?
Сериализация это процесс сохранения состояния объекта в последовательность байт  
Реализована через интерфейс - маркер Serializable.

### Назовите несколько форматов сериализации
JSON, YAML, XML, BSON (binary JSON)

### Для чего нужна сериализация?
Для компактного сохранения состояния объекта и считывание этого состояния.

### Опишите процесс сериализации/десериализации с использованием Serializable
1. Класс объекта должен реализовывать интерфейс Serializable  
2. Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.  
3. Записать в поток: oos.writeObject(Object);  
4. Сделать oos.flush() и oos.close()

### Как изменить стандартное поведение сериализации/десериализации?
Использовать интерфейс Externalizable.    
Переопределить методы  
```java
writeExternal(ObjectOutput out) throws IOException  
readExternal(ObjectInput in) throws IOException, ClassNotFoundException
```
 
### Как создать собственный протокол сериализации?
Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().  
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках.

### Как сериализовать объект класса
Имплементировать интерфейс Serializable, объявить переменную private static final long serialVersionUID, создать поток ObjectoutputStream

### Как сериализовать статическое поле
Можно через Externalizable, но не стоит. Вообще статические поля не сериализуются, т.к. относятся к классу, а не объекту.

### Что делать, если одно из полей сериализовывать не нужно
Добавить модификатор `transient` к полю

### Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?
* Поля с модификатором transient. После восстановления его значение будет null.
* Поле static. Значения статических полей автоматически не сохраняются.  
* Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.

### Особенность сериализации поля final
* Интерфейс Serializable отработает без проблем - он использует рефлексию для создания объекта. При этом используются методы `ObjectInputStream.defaultReadObject()` и `ObjectOutputStream.defaultWriteObject()`.  
* Однако, если мы создадим свои методы `readObject()` и `writeObject()`, то Serizalizable не сможет присвоить значение переменной: будет жаловаться, что она final.  
* У интерфейса Externalizable будет проблема в методе readExternal(). Он не сможет сделать `this.field = in.readValue()`. Потому что создает объект конструктором, а затем меняет значение.

### Сериализация потомков сериализованных родителей
Сериализация дочернего класса, если родительский класс реазлизует интерфейс Serializable возможна, но могут возникнуть проблемы, если в дочернем классе есть не сериализуемые поля.
```java
public class Parent implements Serializable {
    private int i;
    // ...
}

public class Child extends Parent {
    private final Thread t = new Thread();
    // ...
}
```

### В чем проблема сериализации Singleton?
Проблема в том что после десериализации мы получим другой объект. 
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно. 

**Решение**
В классе определяется метод с сигнатурой 
```java
Object readResolve() throws ObjectStreamException
```
Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.

### Что будет если перед десериализцией изменится класс, почему будет выброшено исключение?
Идентификатор версии есть у любого класса, который имплементирует интерфейс Serializable. Он вычисляется по содержимому класса — полям, порядку объявления, методам. И если мы поменяем в нашем классе тип поля и/или количество полей, идентификатор версии моментально изменится. serialVersionUID тоже записывается при сериализации класса. 
Когда мы пытаемся провести десериализацию, то есть восстановить объект из набора байт, значение serialVersionUID сравнивается со значением serialVersionUID класса в нашей программе. Если значения не совпадают, будет выброшено исключение `java.io.InvalidClassException`

### Что будет при сериализации объекта у которого есть поле и оно не Serializable
В таком случае код скомпилируется. Но в рантайме при попытке сериализации , когда мы дойдем до этого поля и объекта, мы получим NotSerializableException.

### Что если при десериализации поменять тип
Будет ошибка. При десериализации проверяется serialVersionUID.

### Какая роль поля serialVersionUID в сериализации?
Поле private static final long serialVersionUID содержит **уникальный идентификатор** версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, **при любом изменении** в классе **это поле поменяет** свое **значение**.  
Если мы не объявляем его явно, Java делает это за нас.

### Когда стоит изменять значение поля serialVersionUID?
Вы должны изменить serialVersionUID только тогда, **когда** вы **сознательно хотите нарушить совместимость со всеми существующими сериализациями**, например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.

### Что такое Externalizable и для чего он нужен?
Externalizable - это интерфейс, который позволяет вам определять пользовательские правила и собственный механизм для сериализации.

### Externalizable vs Serializable
* Externalizable extends Serializable  
* Интерфейс Serializable полностью реализует виртуальная машина JVM.  
* Интерфейс Externalizable имеет методы writeExternal() и readExternal(), которые позволяют вручную указать - какие поля записывать. Это может в том числе повысит производительность.