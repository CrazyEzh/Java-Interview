---
up: [[Коллекции]]
---
# List
---
### Расскажите про интерфейс List
Контейнеры List хранит элементы в порядке добавления. Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка.

### Как устроен ArrayList, сложность основных операций      
ArrayList реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент.  
Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой `trimToSize()`

![[ArrayList_BigO.png]]

### Как устроен LinkedList
**LinkedList** обеспечивает возможность создания двусвязного списка из любых (в том числе и null) элементов. Каждый объект, помещенный в связанный список, является узлом (нодом). Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.

### Отличие ArrayList и LinkedList
Arraylist основан на массиве. LinkedList основан на объектах которые хранят ссылки на след и предыдущий элемент.
Arralist скорость получения элемента O(n). Скорость добавления в конец почти всегда O(n), кроме тех случаев когда увеличиваем размер. Удаление последнего тоже O(n). Но когда вставляем в начало или конец или удаляем в начале или вконце надо двигать все элементы, поэтому скорость падает.Так же удаление явно не уменьшает массив, нужно делать это самим.. LinkedList а постоянное время может выполнять вставку/удаление элементов в списке (именно вставку и удаление, поиск позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь список в поисках последнего элемента). В целом же, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций.

### Когда лучше использовать ArrayList, а когда LinkedList
LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.
Для всех остальных случаев ArrayList.

### Методы ArrayList
* `void add(int index, Object element)` Вставляет указанный элемент в указанный указатель позиции в этом списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index > size()).
* `boolean add(Object o)` Добавляет указанный элемент в конец этого списка.
* `boolean addAll(Collection c)` Добавляет все элементы в указанной коллекции в конец этого списка в том порядке, в котором они возвращаются итератором указанной коллекции. Выбрасывает NullPointerException, если указанная коллекция имеет значение null (нуль).
* `boolean addAll(int index, Collection c)` Вставляет все элементы указанной коллекции в этот список, начиная с указанной позиции. Вызывает NullPointerException, если указанная коллекция имеет значение null (нуль).
* `void clear()` Удаляет все элементы из этого списка.
* `boolean contains(Object o)` Возвращает true, если этот список содержит указанный элемент. Если точнее, то возвращает true тогда и только тогда, когда этот список содержит хотя бы один элемент e такой, что (`o==null ? e==null : o.equals(e)`).
* `Object get(int index)` Возвращает элемент в указанной позиции в этом списке. Вызывает `IndexOutOfBoundsException`, если указанный индекс выходит за допустимые пределы (index < 0 || index >= size()).
* `int indexOf(Object o)` Возвращает индекс в этом списке первого упоминания указанного элемента или -1, если список не содержит этот элемент.
* `int lastIndexOf(Object o)` Возвращает индекс в этом списке последнего упоминания указанного элемента или -1, если список не содержит этот элемент.
* `Object remove(int index)` Удаляет элемент в указанной позиции в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст.
* `boolean remove(Object o)` Удаляет первое упоминание указанного элемента в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за пределы диапазона (index < 0 || index >= size()).
* `int size()` Возвращает количество элементов в этом списке.
* `Object[] toArray()` Возвращает массив, содержащий все элементы в этом списке в правильном порядке. Выбрасывает NullPointerException, если указанный массив равен null (нулю).
* `Object[] toArray(Object[] a)` Возвращает массив, содержащий все элементы в этом списке в правильном порядке; тип выполнения возвращаемого массива - тип указанного массива.
* `void ensureCapacity(int minCapacity)` Увеличивает емкость ArrayList
* `boolean isEmpty()` Возвращает true если коллекция пустая
* `E set(int index, E element)` Заменяет элемент по индексу
* `void trimToSize()` уменьшает емкость коллекции до текущего размера коллекции
* `List<E> subList(int fromIndex, int toIndex)` Возвращает новый List начиная с fromIndex до toIndex (не включительно)

### Методы LinkedList
* `void add(int index, Object element)` Вставляет указанный элемент в указанный указатель позиции в этом списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index > size()).
* `boolean add(Object o)` Добавляет указанный элемент в конец этого списка.
* `boolean addAll(Collection c)` Добавляет все элементы в указанной коллекции в конец этого списка в том порядке, в котором они возвращаются итератором указанной коллекции. Выбрасывает NullPointerException, если указанная коллекция имеет значение null (нуль).
* `boolean addAll(int index, Collection c)` Вставляет все элементы указанной коллекции в этот список, начиная с указанной позиции. Вызывает NullPointerException, если указанная коллекция имеет значение null (нуль).
* `void addFirst(Object o)` Вставляет данный элемент в начало этого списка.
* `void addLast(Object o)` Добавляет данный элемент в конец этого списка.
* `void clear()` Удаляет все элементы из этого списка.
* `boolean contains(Object o)` Возвращает true, если этот список содержит указанный элемент. Если точнее, то возвращает true тогда и только тогда, когда этот список содержит хотя бы один элемент e такой, что (`o==null ? e==null : o.equals(e)`).
* `Object get(int index)` Возвращает элемент в указанной позиции в этом списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index >= size()).
* `Object getFirst()` Возвращает первый элемент в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст.
* `Object getLast()` Возвращает последний элемент в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст.
* `int indexOf(Object o)` Возвращает индекс в этом списке первого упоминания указанного элемента или -1, если список не содержит этот элемент.
* `int lastIndexOf(Object o)` Возвращает индекс в этом списке последнего упоминания указанного элемента или -1, если список не содержит этот элемент.
* `ListIterator listIterator(int index)` Возвращает список-итератор элементов в этом списке (в правильной последовательности), начиная с указанной позиции в списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за пределы диапазона (index < 0 || index >= size()).
* `Object remove(int index)` Удаляет элемент в указанной позиции в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст.
* `boolean remove(Object o)` Удаляет первое упоминание указанного элемента в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за пределы диапазона (index < 0 || index >= size()).
* `Object removeFirst()`Удаляет и возвращает первый элемент из этого списка. Выбрасывает исключение NoSuchElementException, если этот список пуст.
* `Object removeLast()` Удаляет и возвращает последний элемент из этого списка. Вызывает исключение NoSuchElementException, если этот список пуст.
* `Object set(int index, Object element)` Заменяет элемент в указанной позиции в этом списке указанным элементом. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за пределы диапазона (index < 0 || index >= size()).
* `int size()` Возвращает количество элементов в этом списке.
* `Object[] toArray()` Возвращает массив, содержащий все элементы в этом списке в правильном порядке. Выбрасывает NullPointerException, если указанный массив равен null (нулю).
* `Object[] toArray(Object[] a)` Возвращает массив, содержащий все элементы в этом списке в правильном порядке; тип выполнения возвращаемого массива - тип указанного массива.

### Оцените количество памяти на хранение одного примитива типа byte в LinkedList?
Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные. Для x32 систем каждая ссылка занимает 32 бита (4 байта). Сам объект типа Node занимает приблизительно 8 байт. Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются, соответственно получаем еще 8 байт. Таким образом, в x32 JVM около 32 байтов выделяется для хранения одного значения типа byte в LinkedList.  
  
Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт). Вычисления аналогичны.  
Посчитать на других переменных!

### Оцените количество памяти на хранение одного примитива типа byte в ArrayList?
ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.

### Скорость вставки элемента в начало середину и конец у ArrayList и LinkedList
![[ListInsertSpeed.png]]

### Чем массив отличается от ArrayList?
 Массив | ArrayList |
--------|-----------|
Размер должен быть определен при декларировании | Размер можно динамически изменять
Необходимо указать индекс, чтобы добавить данные | Не нужно указывать индекс
Массивы могут содержать примитивные типы данных, а также объекты. | Аррайлисты могут содержать только объекты, примитивные типы данных не допускаются.

### Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?
Можно, но нужно использовать `iterator.remove()`.  
Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента будет `ConcurrentModificationException`.