---
up: [[Коллекции]]
---
# Общие вопросы
---
### Что такое класс коллекции?
Коллекция – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом.

### Какие структуры данных вы знаете
**Массивы  
Стеки  
Очереди  
Связанные списки 
Деревья**  

### Расскажите про иерархию коллекций
![[Collection_ierarchy.png]]

### Отличие коллекции от массива
Массивы обладают значительными недостатками. Одним из них является фиксированный при создании размер массива, как следствие, необходимость следить за размером массива.У массива нет защиты от изменения, если он доступен для чтения, то доступен и для записи. (ключевое слово final не поможет , так как оно защищает от изменения только ссылку на массив, а не сам массив). А коллекции могут разрешать чтение, но запрещать изменение своего содержимого (например методами серии unmodifiable класса Collections, которые возвращают неизменяемое представление указанной коллекции. Этот метод позволяет модулям предоставлять пользователям доступ «только для чтения» к внутренним коллекциям. Операции запроса к возвращаемой коллекции «читают» в указанную коллекцию и попытки изменить возвращенную коллекцию, напрямую или через ее итератор, приводят к исключению UnsupportedOperationException.). У коллекций большое множество удобных методов. Также есть специализированные коллекции предназначенные для многопоточного использования. Все коллекции параметризуются и соответственно могут работать только со ссылочными типами (свойство дженериков).

### На чём основаны основные реализации коллекций
* ***ArrayList** - внутренне ArrayList использует Object[]  
* **LinkedList** - цепь объктов ссылающихся на своих соседей  
* **HashMap** , реализующая интерфейс ассоциативного массива (абстрактная модель «ключ – значение» или entry  
   По сути, это обычный массив, где местоположение элемента зависит от значения самого элемента. Связь между значением элемента и его позицией в хеш-таблице задает хеш-функция.  
   в Java 8 после достижения определенного порога вместо связанных списков используются сбалансированные деревья. Это означает, что HashMap в начале сохраняет объекты в связанном списке, но после того, как колличество элементов в хэше достигает определенного порога происходит переход к сбалансированным деревьям. Что улучшает производительность  
* **TreeMap** - коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном порядке по возрастанию. TreeMap основан на Красно-Черном дереве, вследствие чего TreeMap сортирует элементы по ключу в естественном порядке или на основе заданного вами компаратора.TreeMap гарантирует скорость доступа log(n) для операций containsKey, get, put и remove.  
* **Set** основан на урезанной Map (в паре ключ-значение вместо значения заглушка).  
* **Queue** - основан на Object каждый из которых знает следующий ( + предыдущий) элемент. Это реализовано благодаря внутреннему классу Node который и хранит значение след и пред элементов.

### Начальная ёмкость коллекций
![[Collection_initial_capacity.png]]

### Какая коллекция реализует FIFO?
* Queue

### Какая коллекция реализует LIFO?
* Vector
* ArrayDeque

### Чем Set отличается от List?
Set не добавляет новых методов, только вносит изменения унаследованные.  
В частности, метод `add()` добавляет элемент в коллекцию и возвращает true, если не было такого элемента.
Разрешено наличие только одной ссылки типа null.
Set используется для хранения множест, т.е. все элементы в сете уникальны.

### Почему Map — это не Collection, в то время как List и Set являются Collection?
Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар "ключ"-"значение".  
У map нет Iterable, не понятно по чему проводить итерацию

### В чем разница между java.util.Collection и java.util.Collections?
Класс **java.util.Collections содержит исключительно статические методы для работы с коллекциями.**  
В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), "оболочки", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы.  
**java.util.Collection - это корневой интерфейс Java Collections Framework**. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections.

### Как работает метод contains в ArrayList, LinkedList, HashSet?
* **ArrayList** - метод contains проверяет index данного объекта >= 0? А метод index через equals прогоняет весь массив и возвращает i, индекс искомого элемента.  
* **LinkedList** - тоже самое, сравниваем объект через equals. В методе contains Linked Listа вызывается его же метод - public int indexOf(Object o), где и происходит поиск объекта, последовательными сравнениями объекта из параметров с объектами в nodaх. Соответственно в методе contains проверяется , если indexOf не вернул -1, значит такой объект есть.  
* **HashSet** - проверяется содержит ли map объект (при вызове метода hashSet.contains, внутри него вызывается метод HashMap map.containsKey(объект для поиска) а внути него другой boolean метод hashset getNode(hash(key), key) )В итоге используется сперва сравнение hashcode, если они одинаковые, то equals, если equals == true, то и contains возвращает true
   
### Интерфейсы Comparable и Comparator
**Интерфейс Comparable** содержит один единственный метод int compareTo(E item), который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.  
**Интерфейс Comparator** содержит ряд методов, ключевым из которых является метод compare(): int compare(T a, T b). Метод compare также возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту b, иначе - наоборот. А если метод возвращает ноль, то объекты равны. Для применения интерфейса нам вначале надо создать класс компаратора, который реализует этот интерфейс.

### Красно-чёрные деревья 5 правил
![[RedBlackTree.png]]
* Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета).  
* Корень окрашен в черный цвет. 
* Листья(так называемые NULL-узлы) окрашены в черный цвет.
* Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные.
* Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).

### Что такое бинарное дерево поиска (BST)
Чтобы бороться с длинными linkedList в массиве HashMap начиная с Java 8 разработчики после достижения количеством элементов linkedList определённого порога, вместо связанных списков используются сбалансированные деревья (в основе лежит бинарный поиск)