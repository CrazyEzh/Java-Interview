---
up: [[Коллекции]]
---
# Set
---
### Расскажите про интерфейс Set
Интерфейс Set расширяет интерфейс Collection.  
Set не добавляет новых методов, только вносит изменения унаследованные.  
Set - неупорядоченный набор неповторяющихся элементов  
В частности, метод `add()` добавляет элемент в коллекцию и возвращает true, если не было такого элемента.  
Разрешено наличие только одной ссылки типа null.

### Расскажите про реализации интерфейса Set
В HashSet порядок добавления элементов будет непредсказуемым - используется хэширование для ускорения выборки.  
В TreeSet объекты хранятся отсортированными по возрастанию из-за применения к/ч дерева.  
LinkedHashSet хранит элементы в порядке добавления.

### Как устроен HashSet, сложность основных операций
Все классы, реализующие интерфейс Set, внутренне поддерживаются реализациями Map. HashSet хранит элементы с помощью HashMap. Значение, которые мы передаем в HashSet, является ключом к объекту HashMap, а в качестве значения используется Object.
![[HashSetDiff.png]]

### Как устроен LinkedHashSet, сложность основных операций
В его основе лежит LinkedHashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов

![[LinkedHashSetDiff.png]]

### Как устроен TreeSet, сложность основных операций
Время для базовых операций - Логарифмическое время.  
Гарантирует порядок элементов - в основе лежит красно-черное дерево, которое умеет само себя балансировать.  
Не предоставляет каких-либо параметров для настройки производительности  
Предоставляет дополнительные методы для упорядоченного списка: first(), last(), headSet(), tailSet()

![[TreeSetDiff.png]]

### Упорядоченность в HashSet, LinkedHashSet, TreeSet.
* **HashSet** неупорядочен, потому что реализован на основе HashMap
* **TreeSet** хранит элементы в отсортированном по возрастанию порядке. В основе TreeSet лежит TreeMap(самобалансирующиеся двоичное дерево поиска - ""красно -черное дерево""). У элементов данного TreeMap: ключи - это элементы TreeSet, значения – это константа-заглушка.
* **LinkedHashSet** является наследником HashSet. Хранит информацию о порядке добавления элементов. Производительность методов немного ниже, чем у методов HashSet.В основе LinkedHashSet лежит HashMap. У элементов данного HashMap: ключи - это элементы LinkedHashSet, значения – это константа-заглушка.
```java
private static final Object PRESENT = new Object();)
```

### В чем отличия TreeSet и HashSet?
HashSet быстрее, чем TreeSet .  
В HashSet элементы в случайном порядке, в TreeSet в отсортированном.  
HashSet обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () , remove () и contains () , по сравнению с временем log(n), предлагаемым TreeSet.

### Чем LinkedHashSet отличается от HashSet?
Основное различие в том, что LinkedHashSet сохраняет порядок вставки элементов, а HashSet - нет. В основе LinkedHashSet лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов

### Методы HashSet
* `void add(Object o)` Добавляет указанный элемент к этому набору, если он еще не присутствует.
* `void clear()` Удаляет все элементы из этого набора.
* `Object clone()` Возвращает мелкую копию этого экземпляра HashSet: сами элементы не клонируются.
* `boolean contains(Object o)` Возвращает true, если этот набор содержит указанный элемент.
* `boolean isEmpty()` Возвращает true, если этот набор не содержит элементов.
* `Iterator iterator()` Возвращает итератор над элементами этого набора.
* `boolean remove(Object o)` Удаляет указанный элемент из этого набора, если он присутствует.
* `int size()` Возвращает количество элементов в этом наборе.

### Методы TreeSet
* `void add(Object o)` Добавляет указанный элемент к этому набору, если он еще не присутствует.
* `boolean addAll(Collection c)` Добавляет все элементы в указанной коллекции к этому набору.
* `void clear()` Удаляет все элементы из этого набора.
* `Object clone()` Возвращает мелкую копию этого экземпляра TreeSet.
* `Comparator comparator()` Возвращает компаратор, используемый для порядка этого отсортированного набора, или null (нуль), если этот набор деревьев использует свои элементы естественного упорядочения.
* `boolean contains(Object o)` Возвращает true, если этот набор содержит указанный элемент.
* `Object first()` Возвращает первый (самый низкий) элемент, находящийся в этом отсортированном наборе.
* `SortedSet headSet(Object toElement)` Возвращает представление (вид) части этого набора, элементы которого строго меньше, чем toElement.
* `boolean isEmpty()` Возвращает true, если этот набор не содержит элементов.
* `Iterator iterator()` Возвращает итератор над элементами этого набора.
* `Object last()` Возвращает последний (самый высокий) элемент, находящийся в этом отсортированном наборе.
* `boolean remove(Object o)` Удаляет указанный элемент из этого набора, если он присутствует.
* `int size()` Возвращает количество элементов в этом наборе.
* `SortedSet subSet(Object fromElement, Object toElement)` Возвращает представление (вид) части этого набора, элементы которого варьируются от fromElement, включительно, до toElement, исключительно.
* `SortedSet tailSet(Object fromElement)` Возвращает представление (вид) части этого набора, элементы которого больше или равны fromElement.

### Почему в HashSet вместо value не null а new Object
Методы HashSet делегируют выполнение HashMap, а в Map методы get или remove возвращают null если не нашли объект. В случае если бы вместо object был бы null, логика этих методов была бы нарушена. Было бы не понятно null, т.к. не нашли элемент или null т.к. это значение null

### Что будет, если добавлять элементы в TreeSet по возрастанию?
TreeSet все равно в каком порядке вы добавляете в него элементы, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию.

### Null в TreeSet
Для пустого TreeSet в первом элементе может быть вставлено значение `null`, но после вставки этого первого значения, если мы пытаемся вставить какие-либо другие объекты, мы получим `NullPointerException`. Это происходит потому, что, когда в дереве существуют некоторые элементы, перед вставкой любого объекта он сравнивает новый объект с существующими с помощью метода `compareTo()` и решает, куда поместить новый объект. Таким образом, вставляя null, метод `compareTo()` внутренне вызывает `NullPointerException`