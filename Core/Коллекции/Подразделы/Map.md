---
up: [[Коллекции]]
---
# Map
---
### Что такое Map
Map — это структура данных, которая содержит набор пар “ключ-значение”. По своей структуре данных напоминает словарь, поэтому ее часто так и называют. В то же время, Map является интерфейсом.

### Какие существуют реализации Map?
 В стандартном jdk содержит основные реализации: Hashmap, LinkedHashMap, Hashtable, TreeMap. Самая используемая реализация — Hashmap
 
### Что должно быть уникальным в Map
Ключ. Очень важно в качестве ключа использовать Immutable объекты, т.е. объекты, которые мы не можем изменить. Например этого можно добиться поставить для каждого поля final и для класса тоже final, чтобы он не мог иметь наследников. Иначе, если например изменится значение поля (а оно как правило участвует в вычислении hashCode объекта), то изменится и hashCode, а это недопустимо, если имеешь дело с HashMap. Вот поэтому объект который стоит на месте ключа, должен быть immutable, иначе мы потеряем доступ по этому ключу. Естественно чтобы объект был полностью Immutabe ему нужно поля сделать еще и private и сделать getterы.

### Расскажите подробно, как работает метод put
* Вычисляем haschCode ключа.
* На основе хеша получаем индекс бакета.
* Создаем объект Node 
* Помещаем объект Node в бакет
* Если бакет занят, то получаем коллизию.  В таком случае проверяем с помощью методов hashCode() и equals(), что оба ключа одинаковы.
```java
(p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
```
* Если ключи одинаковые заменяем значения
* Если ключи разные связать новый и старый объекты с помощью структуры данных "связанный список, указав ссылку на следующий объект в текущем и сохранить оба в вычисленном ранее бакете. 

### Как устроена HashMap, сложность основных операций? (Расскажите про принцип корзин)
**HashMap** – внутри состоит из корзин и списка элементов, на которые ссылаются корзины.  
Корзины – массив  
Элементы(Node) – связанный список, то есть каждый элемент списка имеет указатель на следующий элемент.  
При добавлении нового элемента, хэш-код ключа определяет корзину для элемента с помощью hashFunction(), который принимает hashCode ключа и возвращает номер корзины. В корзине есть ссылка на связанный список, в который будет положен наш объект. Идет проверка, есть ли элементы в этом списке. Если нету, то корзина получает ссылку нового элемента, если есть, то происходит прохождение по списку элементов и сравнивание элементов в списке. Проверяется равенство hashcode. Зная о коллизии, проводится еще сравнивание ключей методом equals.  
Если оба равны: идет перезапись  
Если не равен equals: добавляется элемент в конец списка  
  
HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75. Его произведение на количество корзин дает нам необходимое число объектов которое нужно добавить чтобы состоялось удвоение количества корзин.  
Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то расширение произойдет когда мы добавим 16 * 0.75 = 12 объектов.  
После удвоения все объекты будут перераспределены с учетом нового количества корзин

![[HashMapDiff.png]]

### Методы HashMap
* `void clear()` Удаляет все соответствия с этого Map.
* `Object clone()` Возвращает мелкую копию этого экземпляра HashMap: сами ключи и значения не клонируются.
* `boolean containsKey(Object key)` Возвращает true, если этот Map содержит отображение для указанного ключа.
* `boolean containsValue(Object value)` Возвращает true, если этот Map отображает одну или несколько клавиш в указанное значение.
* `Set entrySet()` Возвращает представление (вид) коллекции отображений, содержащихся в этом Map.
* `Object get(Object key)` Возвращает значение, для которого указанный ключ отображается в этой хэш-карте идентификатора, или null (нуль), если Map не содержит отображения для этого ключа.
* `boolean isEmpty()` Возвращает true, если этот Map не содержит отображений значений ключа.
* `Set keySet()` Возвращает заданное представление (вид) ключей, содержащихся на этом Map.
* `Object put(Object key, Object value)` Связывает указанное значение с указанным ключом на этом Map.
* `putAll(Map m)` Копирует все отображения с указанного Map на этот Map. Эти отображения заменят любые отображения, которые это отображение имело для любого из ключей, находящихся в настоящее время на указанном Map.
* `Object remove(Object key)` Удаляет отображение для этого ключа с этого Map, если присутствует.
* `int size()` Возвращает количество ключ-значение отображений на этом Map.
* `Collection values()` Возвращает представление (вид) коллекции значений, содержащихся на этой карте.

### Какой изначальный размер HashMap?
Изначальный размер 16. Комментарий к дефолтному конструктору HashMap
>Constructs an empty HashMap with the default initial capacity (16) and the default load factor (0.75).

### Какой хэш-код у null в HashMap
Из исходного кода HashMap, если ключ равен `null`, он обрабатывается по-другому. Для `null` не создается хэш-код, но он уникально хранится в индексе 0 во внутреннем массиве с хеш-значением 0. Также обратите внимание, что хеш-значение пустой строки также равно 0 (в случае, если ключи являются строками), но индекс, в котором он хранится во внутреннем массиве другой, чтобы они не перепутались.

### Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?
По значению `hashCode()` вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким `hashCode()` уже присутствует, но их `equals()` методы не равны, то элемент будет добавлен в конец списка.

### Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?
Объект скорее всего добавится, но обратно мы не сможем получить его.

### Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?
Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.

### Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

### Как расширяется HashMap
При создании HashMap мы можем задать 2 параметра, которые очень влияют на производительность:
* Initial capacity – начальный размер массива (чем больше начальный capasity, тем больше памяти занимает, но тем меньшей длины будут linkedList  внутри ячейки массива и тем быстрее поиск, т.е. мы можем пожертвовать памятью, но выиграть во времени доступа к элементу);
* Load factor – коэффициент того, насколько массив должен быть заполнен, после чего его размер будет увеличен вдвое.(чем больше load factor, тем больше мы будем экономить памяти, но тем медленнее будет поиск) load factor 0.75 считается "золотой серединой" между экономией памяти и экономией времени.

Initial capasity обозначает, что заполнено будет 75% capasity, то его capasity будет увеличено вдвое и все элементы содержащиеся в массиве будут рехэшированы (то есть исходя из хэша, который содержит нода, будет рассчитан на какой индекс нового массива будет определена нода)

### Интерфейс Entry и метод entrySet()
`entrySet()` возвращает множество entry (entry это интерфейс внутренний для map, который имплементируется нашим классом, внутренним для hashMap -  Node (а Node содержит ключ, значение, хэш ключа и ссылку на следующий элемент)), поэтому с помощью этого entry мы можем добраться и до ключа и до значения.

### Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?
O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.

### Какое худшее время работы метода get(key) для ключа, который есть в HashMap?
O(N) - линейное

### Может ли null быть ключём в HashMap
Может, но только 1

### Как работает метод get в HashMap
* Вычисляем хеш ключа
* На основе его получаем индекс бакета
* Перейти по индексу бакета и сравнить ключ первого элемента с имеющемся значением. Если они равны -вернуть значение, иначе выполнить проверку для следующего элемента, если он существует.

### Условия перестраивания HashMap в красно-чёрное дерево
В Java 8 после достижения определенного порога вместо связанных списков используются сбалансированные деревья. Это означает, что HashMap в начале сохраняет объекты в связанном списке, но после того, как колличество элементов в хэше достигает определенного порога происходит переход к сбалансированным деревьям. Что улучшает производительность в худшем случае с O(n) до O(log n)

### Почему нельзя использовать byte[] в качестве ключа в HashMap?
Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Также у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

### Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?
Одним из основных требований к использованию HashMap является неизменяемость ключа, однако это требование не распространяется на IdentityHashMap, который не использует методы equals() и hashCode().

### Что такое loadFactor и initialCapactity в HashMap?
* Initial capacity – начальный размер массива (чем больше начальный capasity, тем больше памяти занимает, но тем меньшей длины будут linkedList  внутри ячейки массива и тем быстрее поиск, т.е. мы можем пожертвовать памятью, но выиграть во времени доступа к элементу);
* Load factor – коэффициент того, насколько массив должен быть заполнен, после чего его размер будет увеличен вдвое.(чем больше load factor, тем больше мы будем экономить памяти, но тем медленнее будет поиск) load factor 0.75 считается "золотой серединой" между экономией памяти и экономией времени.

### В чем разница между Hashtable и HashMap?
Главное отличие в том, что методы класса Hashtable синхронизированы, а HashMap - нет. Кроме этого класс HashMap в отличии от Hashtable разрешает использование null в качестве ключей и значений.

### Как устроена TreeMap, сложность основных операций?
Класс TreeMap<K, V> представляет отображение в виде дерева. Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap. Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей.

![[TreeMapDiff.png]]