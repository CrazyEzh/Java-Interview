---
up: [[Stream API]]
---
# Общие вопросы по Stream API
---
### Что такое Stream API? Для чего нужны стримы?
Интерфейс java.util.Stream представляет собой последовательность элементов, над которой можно производить различные операции.  
Операции над стримами бывают или промежуточными или терминальными. Терминальные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.  
Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.

### Как работает Stream
У стримов есть некоторые особенности. Во-первых, обработка не начнётся до тех пор, пока не будет вызван терминальный оператор. list.stream().filter(x -> x > 100); не возьмёт ни единого элемента из списка. Во-вторых, стрим после обработки нельзя переиспользовать.  
Пока мы не присоединили терминальный оператор, доступа к источнику не проводилось. Как только появился терминальный оператор forEach, он стал запрашивать элементы у стоящего перед ним оператора limit. Тот в свою очередь обращается к map, map к filter, а filter уже обращается к источнику. Затем элементы поступают в прямом порядке: источник, filter, map, limit и forEach.  
Пока какой-либо из операторов не обработает элемент должным образом, новые запрошены не будут.  
Как только через оператор limit прошло 3 элемента, он переходит в закрытое состояние и больше не будет запрашивать элементы у map. forEach запрашивает очередной элемент, но limit сообщает, что больше не может поставить элементов, поэтому forEach делает вывод, что элементы закончились и прекращает работу.    
Такой подход зовётся pull iteration, то есть элементы запрашиваются у источника по мере надобности.

### В каком пакете находится Stream?
```java
java.util.Stream
```

### Чем является Stream в контексте Java?
Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете java.util.stream.  
Теперь вместо цикла и кучи условных конструкций, которые мы бы использовали до JDK 8, мы можем записать цепочку методов, которые будут выполнять те же действия.

### Чем Stream отличается от итератора?
Итератор - это очень простой объект, который умеет только выдавать элементы по одному. А стрим гораздо более сложный - у стрима огромное количество методов . Он представляет не просто средство обхода элементов, а средство описания алгоритма обработки и преобразования последовательности элементов

### Почему Stream называют ленивым?
Методы не будут выполняться пока не будет вызван терминальный метод

### Из каких частей состоит использование стримов?
Использование стрима состоит из 3х частей:  
* Получение стрима (откуда будут браться элементы последовательности. Есть много разных способов получить стрим)  
* Ноль или более промежуточных операций преобразований, стрим их просто запоминает, но пока не выполняет  
* Единственная терминальная операция, запускающая весь процесс вычисления и которая должна стать его полезным результатом  
+ есть ещё опциональный заключительный шаг - это закрытие стрима - вызов его метода close();

### Сравнение стримов с коллекцией
* Коллекции предполагают хранение всего набора элементов и соответственно - конечны, а стрим потенциально может быть бесконечным.  
* Коллекции часто предоставляют индивидуальный доступ к своим элементам(например по индексу или по ключу), а стрим такого не позволяет  
* Коллекции можно менять, добавлять или удалять элементы, в том числе через итератор, а применение трансформации к стриму никак не влияет на тот источник из которого элементы берутся

### Какие бывают стримы?
* **По типу действия** (конечные и бесконечные)
* **По методу работы** (последовательные и параллельные)
* **По внутренним составляющим** (объектные и примитивные)

### Какие существуют способы создания стрима?
* Пустой стрим: Stream.empty()  
* Стрим из List: list.stream()  
* Стрим из Map: map.entrySet().stream()  
* Стрим из массива: Arrays.stream(array)  
* Стрим из указанных элементов: Stream.of("1", "2", "3")  
* Можно получить из BufferedReader при помощи метода lines(), который вернет поток строк из потока символов.  
* Из директории на диске при помощи методов Files.list() и Files.walk()  
* Можно получить из строки методом chars(), будет IntStream с символами.  
* Можно порождать динамически, генерировать при помощи supplier.  
* Итерированием какой-то функции  
* Можно получить диапазон чисел в виде стрима range и rangeClosed  
* Конкатенацией других стримов

### Как из коллекции создать стрим?
```java
Collection<String> collection = Arrays.asList("a1", "a2", "a3");  
Stream<String> streamFromCollection = collection.stream();
```

### Как получить стрим диапазона чисел?
`.range`
`.rangeClosed`
Range – создает стрим из элементов от а до б, где б не включается  
rangeClosed – создает стирим от а до б, где б включительно

### Как получить стрим из массива?
```java
Arrays.stream(array) // Stream<String>
``` 

### Можно ли конкатенировать стримы? если да то каким методом? Можно ли получить пустой стрим?
Да, методом concat(stream1, stream2)  
Пустой стрим пожно получить с помощью метода .empty

### Может ли стрим использоваться повторно?
Стримы "одноразовые", т.е. после вызова терминальной операции стрим больше не пригоден к использованию

### Первый этап работы со стримом
Первый этап - это порождение стрима.

### Какой второй этап работы со стримом?
Второй этап работы со стримом - это промежуточные операции.

### Для чего терминальные операции? Какие бывают и что делают?
Третий этап работы со стримом - это терминальные операции, производящие какой то полезный результат. Терминальная операция запускает всю цепочку стримов на исполнение.  
* forEach – принимает consumer, которому будут выведены элементы стрима. 
* forEachOrdered – как и forEach, но гарантирует порядок. 
* count() - подсчет всех значений
* max() - возвращает максимальный элемент
* min() - возвращает минимальный элемент
* findAny() - находится вхождение – сразу возвращает результат
* anyMatch() проверяет на наличие совпадения
* allMatch() – возвращает boolean
* noneMatch() – возвращает boolean 
* findFirst – возвращает первый элемент из стрима, возвращается OptionalInt
* collect – собирает элементы в новое хранилище
* reduce – результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.
* toArray  - возвращет массив

### Расскажите о параллельной обработке в Java 8
Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel. А обратный метод - sequential(). Кроме того, можно также использовать блокирующий метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.  
Работает на фреймворке fork/join.

### В каком случае нужно закрывать стрим?
Вызов метода close() стрима по окончании работы обязателен только в том случае, когда стрим выделял какие то системные ресурсы (Например если стрим связан с содержимым файла или директории на диске, то закрыть его надо, чтобы избежать утечек ресурсов). Благодаря тому , что стрим реализует интерфейс Autocloseble, его можно использовать в конструкции "try с ресурсами".

### Что такое IntStream и DoubleStream?
В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : **IntStream, LongStream, DoubleStream**. Работает быстрее, чем стрим с классами-обертками.  
Поддерживают дополнительные терминальный методы sum(), average(), mapToObj()

### Расскажите про класс Collectors и его методы
Нужен для того, чтобы упаковывать стримы в коллекции:  
```java
toList() // преобразует поток в список — List<T>  
toSet() // преобразует поток в список — Set<T>  
toMap() // преобразует поток в список — Map<K, V>  
```
Используются в методе collect().
