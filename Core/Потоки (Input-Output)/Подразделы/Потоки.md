---
up: [[Потоки (Input-Output)]]
---
# Потоки
---
### Что такое InputStream и OutputStream
**Поток Stream** - это абстрактное понятие источника или приёмника данных, которые способны обрабатывать информацию.
**InputStream** - это поток байтов из которого можно читать по одному байту или блоками.
**OutputStream** - это поток байтов в который можно писать.
**Базовый класс InputStream** - это абстрактный класс, определяющий входной поток данных, и является родителем для классов, получающих данные из различных источников : массив байтов, строки (String), файлы, каналы pipe, у которых одна из сторон является входом, а вторая сторона играет роль выхода, и т.д. Методы класса InputStream при возникновении ошибки вызывают исключение IOException.
**Класс OutputStream** - это абстрактный класс, определяющий байтовый поток вывода. Наследники данного класса определяют куда направлять данные: в массив байтов, в файл или канал. Из массива байт можно создать текстовую строку String.

Оба класса абстактные и на этом уровне даже неизвестно с каким конкретно источником или получателем данных работают эти стримы.

### InputStream / OutputStream / Reader / Writer. Что делают и для чего? Реализации. Разница
**Абстрактный класс Reader**
Класс Reader обеспечивает поддержку символьного потока чтения аналогично тому, как это делает InputStream, реализующий модель байтового потока ввода.

При реализации Reader требуется, чтобы производный класс (наследник) обеспечил практическое воплощение варианта метода read, осуществляющего чтение данных в массив символов, и версии метода close. Во многих случаях, однако, производительность операций может быть улучшена за счет переопределения в производных классах и других методов.

*Наследники класса Reader*
* **BufferedReader** - буферизированный входной символьный поток; увеличивает производительность за счёт буферизации ввода;
* **CharArrayReader** - входной поток чтения символьного массива;
* **FileReader** - входной поток чтения содержимого файла; в конструкторе класса нужно указать либо путь к файлу, либо объект типа File;
* **FilterReader** - фильтрующий читатель;
* **InputStreamReader** - входной поток, транслирующий байты в символы;
* **LineNumberReader** - входной поток, подсчитывающий строки;
* **PipedReader** - входной канал;
* **PushbackReader** - входной поток, позволяющий возвращать символы обратно в поток;
* **StringReader** - входной поток, читающий из строки.

**Абстрактный класс Writer**
Абстрактный класс Writer обеспечивает поддержку символьного потока записи аналогично тому, как это делает OutputStream, реализующий модель байтового потока вывода

Классы, производные от Writer, должны реализовать вариант метода write, связанного с записью символов из части массива, а также методов close и flush. Все остальные методы Writer основаны на трех методах, названных выше. Это отличает Writer от класса OutputStream, в котором в качестве базового метода вывода предусмотрен вариант write, осуществляющий вывод одного байта, а для методов flush и close предложены реализации по умолчанию.

*Наследники класса Writer*
* **BufferedWriter** - буферизированный выходной символьный поток; позволяет повысить производительность за счёт снижения количества операций физической записи в выходное устройство;
* **CharArrayWriter** - выходной поток, который пишет в символьный массив;
* **FileWriter** - выходной поток, пишущий в файл; в конструкторе можно определить вывод в конец файла. Создание объекта не зависит от наличия файла, он будет создан в случае необходимости. Если файл существует и он доступен только для чтения, то передаётся исключение IOException
* **FilterWriter** - фильтрующий писатель
* **OutputStreamWriter** -выходной поток, транслирующий байты в символы
* **PipedWriter** - выходной канал
* **PrintWriter** - выходной поток, включающий методы print() и println()
* **StringWriter** - выходной поток, пишущий в строку

### Отличие пакетов IO и NIO, InputStream от Reader
**Java IO (input-output)** является потокоориентированным, а **Java NIO (new/non-blocking io)** – буфер-ориентированным. Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. В Java NIO данные сначала считываются в буфер, что дает больше гибкости при обработке данных.
Потоки ввода/вывода в Java IO являются блокирующими. Это значит, что когда в потоке выполнения вызывается read() или write() метод любого класса из пакета java.io.\*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого. Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим. Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.
В Java NIO имеются селекторы, которые позволяют одному потоку выполнения мониторить несколько каналов ввода. Т.е. существует возможность зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.

### Почему важно закрывать потоки
При закрытии потока освобождаются все выделенные для него ресурсы, например, файл. В случае, если поток окажется не закрыт, может происходить утечка памяти.

### Что такое System.in, что такое System.out?
Стандартный поток ввода (клавиатура) в Java представлен объектом — System.in. А стандартный поток вывода (дисплей) — уже знакомым вам объектом System.out

### Какие потоки можно не закрывать (не вызывать метод close())
Которые объявлены в try-with- resourses  
Класс `ByteArrayOutputStream` использует байтовый массив в выходном потоке. Метод close() можно не вызывать.  
Всегда хорошая практика - закрыть своих читателей. Однако не закрытие `ByteArrayInputStream` не имеет такого большого потенциального отрицательного эффекта, потому что вы не получаете доступ к файлу, а просто к массиву байтов в памяти.

### На каком паттерне основана иерархия потоков ввода/вывода
Объекты классов Java, которые используются для ввода/вывода, для обеспечения необходимой функциональности наслаиваются друг на друга(модель матрешки). Такая модель взаимодействия объектов поддерживается в паттерне «Декоратор». В этом паттерне при создании потока нужно использовать несколько объектов.

Признаки применения паттерна: Декоратор можно распознать по создающим методам, которые принимают в параметрах объекты того же абстрактного типа или интерфейса, что и текущий класс.

Адаптер InputStreamReader(InputStream in, String charsetName) - совмещаем разные классы
Декоратор - вкладываем потом к бафферпоток - получаем новый функционал. 

### Что такое паттерн адаптер
**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

### Пример адаптера и декоратора из IO
**Класс InputStreamReader** — это классический адаптер.
Мы можем передать в его конструктор объект InputStream. Чаще всего мы для этого используем переменную System.in:
```java
public static void main(String[] args) {
   InputStreamReader inputStreamReader = new InputStreamReader(System.in);
}
```
Что же делает InputStreamReader? Как и всякий адаптер, он преобразует один интерфейс к другому. В данном случае — интерфейс InputStream’a к интерфейсу Reader’a. Изначально у нас был класс InputStream. Он неплохо работает, но с его помощью можно читать только отдельные байты. Кроме того, у нас есть абстрактный класс Reader. У него есть отличный и очень нужный нам функционал — он умеет читать символы! Нам такая возможность, конечно, очень нужна. Но здесь мы сталкиваемся с классической проблемой, которую обычно решают адаптеры — несовместимость интерфейсов. В чем же она проявляется? Интерфейсы InputStream'a и Reader'a несовместимы! Во всех реализациях метода read() у них отличаются и передаваемые параметры, и возвращаемые значения. InputStreamReader выступит Адаптером между нашими классами.

Декоратор - Декоратор — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.
**Абстрактный декоратор – FilterInputStream, его потомки – конкретные декораторы:**
* BufferedInputStream - буферизует ввод для повышения производительности и дополняет интерфейс новым методом readLine() для построчного чтения символьных данных.
* LineNumberInputStream - добавляет возможность подсчета строк в процессе чтения данных.