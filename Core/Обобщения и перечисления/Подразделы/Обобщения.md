---
up: [[Обобщения и перечисления]]
---
# Обобщения
---
### Что такое дженерики
Дженерики – это параметризованные типы.  
С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра.  
Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных.  
Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List\<Object> list вместо List\<String> list, например.  
Появились в версии 1.5

### Для чего нужны дженерики?
Для строгой типизации и проверки на этапе компиляции.  
Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения.

### Что такое даймонд оператор
<> это особый синтаксис, который добавили в Java SE 7, и называется он "the diamond". Diamond синтаксис связан с понятием "Type Inference", или же " вывод типа". Компилятор, видя справа даймонд <> смотрит на левую часть, где расположено объявление типа переменной, в которую присваивается значение. И по этой части понимает, каким типом типизируется значение справа. Даймонд оператор работает только вместе с ключевым словом "new".

### Что такое сырые типы (raw type)?
Сырые типы — это типы без указания типа в фигурных скобках ( List list = new ArrayList<>() ), они использовались до появления дженериков.  
Не указывая их, под капотом используется Object.

### К чему приводит использование raw type
Придется делать приведение типов из оbject. И придется самому делать проверку типов.

### Отличие raw type от даймонд оператора
Даймонд оператор защищает нас от неправильного кода, например когда мы в лист интеджеров хотим засунуть лист стрингов.

### Что можно параметризировать
Enum, Исключения, но:  
Можно выбрасывать исключение generic-типа.  
Чтобы объявить, что метод выбрасывает исключение обобщенного типа T, этот тип T должен быть объявлен расширяющим Throwable. Именно в Throwable в таком случае сотрется T при компиляции. Также в качестве типа-верхней границы можно использовать любого наследника Throwable:  
```java
class MyClass<T extends IOException> {  
	void foo() throws T {  
	// ...  
	}  
}  
```
Нельзя использовать дженерик в catch.  
Множественные блоки catch должны идти без повторений, в определенном порядке – от специфичного класса к более базовому. Стирание типов-параметров в связи с этими правилами добавило бы путаницу, не неся особой пользы.  
Владыкин  
Значением параметра не может быть примитивный тип или значение.

### Как параметризовать статический метод
* Если метод статический, то унаследовать параметр типа от класса он не может. Это вызвано тем, что параметр типа привязывается к конкретному объекту при его создании, а статический метод не привязан к конкретному объекту, он привязан к классу в целом. 
* В случае статического метода параметр типа нужно указывать непосредственно перед объявлением имени метода.В этом случае тип T определяется в момент вызова статического метода по типу передаваемого аргумента.

### Чему эквивалентно \<?>
Может быть подставлен любой тип

### Можно ли объявить так: class Animal\<?> {}
Нет компилятор не пропустит : "Unexepected wildcard" .С wildcard не всё разрешается делать по той причине, что может нарушиться Type Safe (типобезопасность), что очень нежелательно. Вместо ? надо писать Т, и тогда, вы гарантированно будете работать с одним конкретным типом Т.

### Какой механизм обеспечивает обратную совместимость сырых типов и дженериков
Стирание типов

### Если поле типизировано дженериком как в байт коде будет представлен этот тип
Object (c кастом до типа, указанного в дженерике)  

### Что было до дженериков
Все это было сделано с Object (и было много кастинга)  
```java
ArrayList list = new ArrayList();  
list.add(new Thingy());  
// ...  
Thingy t = (Thingy)list.get(0);  
// Note ---^^^^^^^^  
```
Список знал только то , что он хранил, было Object, это зависело от кода, использующего список, чтобы вернуться к полезному типу.  
  
Как вы можете себе представить, это привело к всевозможным unpleasantness —, которые вы могли поместить в список не тот тип объекта, а затем получить ClassCastException, когда вы попытались привести его к ожидаемому типу; если вы изменили то, что было в списке, вам пришлось менять свои приведения везде и неизбежно забыть один и т. Д., и т. Д. Дженерики помогли устранить эти болевые точки.

### Что такое вайлдкарды? 
Маске (wildcard) можно задать ограничения:  
* “? extends T” (для получения в методе) - объект, который наследуется от Т, либо сам Т – ковариантность.  Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.  
* “? super T” (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность. Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object  
  
При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. \<?> - неограниченный символ подстановки. \<?> означает то же что и \<? extends Object>, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.

### Расскажите про принцип PECS
Producer Extends Consumer Super  
wildcard подстановочный знак:  
Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает.  
Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.  
  
Иначе говоря:  
Если вы только получаете объекты из дженерик-коллекции - это producer и надо использвовать extends.  
Если вы только кладете объекты в коллекцию - это consumer и надо использовать super.  
Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.
