---
up: [[SQL]]
---
# Функции и структура БД
### Что делает оператор MERGE? Какие у него есть ограничения?
MERGE позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT. При этом изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц, нельзя.  
```sql
MERGE Ships AS t -- таблица, которая будет меняться
USING (SELECT запрос ) AS s ON (t.name = s.ship) -- условие слияния 
THEN UPDATE SET t.launched = s.year -- обновление
WHEN NOT MATCHED -- если условие не выполняется 
THEN INSERT VALUES(s.ship, s.year) -- вставка
```

### Какие агрегатные функции вы знаете?
Агрегатных функции - функции, которые берут группы значений и сводят их к одиночному значению.  
Несколько агрегатных функций:  
* COUNT - производит подсчет записей, удовлетворяющих условию запроса;  
* CONCAT - соединяет строки;  
* SUM - вычисляет арифметическую сумму всех значений колонки;  
* AVG - вычисляет среднее арифметическое всех значений;  
* MAX - определяет наибольшее из всех выбранных значений;  
* MIN - определяет наименьшее из всех выбранных значений.

### Что такое ограничения (constraints)? Какие вы знаете?
Ограничения - это ключевае слова, которые помогают установить правила размещения данных в базе. Используются при создании БД.  
  
* NOT NULL указывает, что значение не может быть пустым.UNIQUE обеспечивает отсутствие дубликатов.  
* PRIMARY KEY - комбинация NOT NULL и UNIQUE. Помечает каждую запись в базе данных уникальным значением.CHECK проверяет вписывается ли значение в заданный диапазон ( s_id int CHECK(s_id > 0) )  
* FOREIGN KEY создает связь между двумя таблицами и защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой.DEFAULT устанавливает значение по умолчанию, если значения не предоствлено (name VARCHAR(20) DEFAULT 'noname').  
  
Какие отличия между PRIMARY и UNIQUE?  
По умолчанию PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный. PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись.  
Таблица может иметь один PRIMARY KEY и много UNIQUE.  
  
Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?  
Может, если на данный столбец не наложено ограничение NOT NULL.

### Что такое суррогатные ключи?
Суррога́тный ключ — это дополнительное служебное поле, автоматически добавленное к уже имеющимся информационным полям таблицы, предназначение которого — служить первичным ключом.

### Что такое индексы? Какие они бывают?
Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс создает структуру для индексируемого поля. Необходимо просто добавить указатель индекса в таблицу.  
  
Есть три типа индексов, а именно:
* Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения. Если первичный ключ определен, уникальный индекс применен автоматически.
* Кластеризованный индекс (Clustered Index): сортируют и хранят строки данных в таблицах или представлениях на основе их ключевых значений. Это ускоряет операции чтения из БД.
* Некластеризованный индекс (Non-Clustered Index): внутри таблицы есть упорядоченный список, содержащий значения ключа некластеризованного индекса и указатель на строку данных, содержащую значение ключа. Каждый новый индекс увеличивает время, необходимое для создания новых записей из-за упорядочивания. Каждая таблица может иметь много некластеризованных индексов.
Как создать индекс? b3  
Индекс можно создать либо с помощью выражения CREATE INDEX:  
CREATE INDEX index_name ON table_name (column_name)  
либо указав ограничение целостности в виде уникального UNIQUE или первичного PRIMARY ключа в операторе создания таблицы CREATE TABLE.
Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?  
Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.
Когда полное сканирование набора данных выгоднее доступа по индексу?  
Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором.  
Таким образом, полное сканирование выбирается при слабой селективности предикатов зароса и/или слабой кластеризации данных, либо в случае очень маленьких наборов данных.

### Что такое хранимые процедуры? Для чего они нужны?
**Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере**. Хранимые процедуры очень похожи на обыкновенные методы языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.  
Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.

### Что такое представления (VIEW)? Для чего они нужны?
**View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом.** В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.  
Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).

### Что такое временные таблицы? Для чего они нужны?
**Подобные таблицы удобны для каких-то временных промежуточных выборок из нескольких таблиц.** Создание временной таблицы начинается со знака решетки #. Если используется один знак #, то создается локальная таблица, которая доступна в течение текущей сессии. Ели используются два знака ##, то создается глобальная временная таблица. **В отличие от локальной глобальная временная таблица доступна всем открытым сессиям базы данных.**  
```sql
CREATE TABLE #ProductSummary  
(ProdId INT IDENTITY,  
ProdName NVARCHAR(20),  
Price MONEY)
```

### Что такое транзакции? Расскажите про принципы ACID
Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.  
  
ACID-принципы транзакций:  
* Атомарность (atomicity) гарантирует, что транзакция будет полностью выполнена или потерпит неудачу, где транзакция представляет одну логическую операцию данных. Это означает, что при сбое одной части любой транзакции происходит сбой всей транзакции и состояние базы данных остается неизменным.  
* Согласованность (consistency). Транзакция, достигающая своего завершения и фиксирующая свои результаты, сохраняет согласованность базы данных  
* Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат.  
* Долговечность (durability). Независимо от проблем (к примеру, потеря питания, сбой или ошибки любого рода) изменения, сделанные успешно завершённой транзакцией, должны остаться сохраненными после возвращения системы в работу.

### Расскажите про уровни изолированности транзакций
В порядке увеличения изолированности транзакций и, соответственно, надежности работы с данными:  
* Чтение неподтверждённых данных (read uncommitted) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, измененные другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Возможны неповторяемое чтение, фантомы и грязное чтение.  
* Чтение подтвержденных данных (read committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций, но процессы-писатели могут изменять уже прочитанные читателем данные. Возможны неповторяемое чтение и фантомы.  
* Повторяемость чтения (repeatable read) — Уровень, позволяющий предотвратить неповторяемое чтение. Т.е. мы не видим в исполняющейся транзакции измененные и удаленные записи этой же или другой транзакцией. Но все еще видим вставленные записи из другой транзакции. В MySQL и PostgreSQL отсутствует эффект чтения фантомов для этого уровня.  
 * Упорядочиваемость (serializable) — гарантирует неизменяемость данных другими процессами до завершения транзакции. Проблемы синхронизации не возникают.

При параллельном выполнении транзакций возможны следующие проблемы:  
Потерянное обновление (lost update) — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;  
«Грязное» чтение (dirty read) — чтение данных, добавленных или измененных транзакцией, которая впоследствии не подтвердится (откатится);  
Неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются измененными;  
Фантомное чтение (phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей.
<iframe width="760" height="427" src="https://www.youtube.com/embed/5Z2iFX3OeTo?controls=0"  frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
[Дополнительная информация на Habr](https://habr.com/ru/post/469415/)

### Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?
**Нормализация** - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс приведения данных в более простую и логичную структуру).Целью является уменьшение потенциальной противоречивости хранимой в базе данных информации.

**Денормализация базы данных** — это процесс обратный от нормализации. Эта техника добавляет избыточные данные в таблицу, учитывая частые запросы к базе данных, которые объединяют данные из разных таблиц в одну таблицу. Необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных.  
  
Каждая нормальная форма включает в себя предыдущую. Типы форм:  
* Первая нормальная форма (1NF) - значения всех полей атомарны (неделимы), нет множества значений в одном поле.  
* Вторая нормальная форма (2NF) - все неключевые поля зависят только от ключа целиком, а не от какой-то его части.  
* Третья нормальная форма (3NF) - все неключевые поля не зависят друг от друга.  
* Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF) - когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.  
* Четвёртая нормальная форма (4NF) - не содержатся независимые группы полей, между которыми существует отношение «многие-ко-многим».  
* Пятая нормальная форма (5NF) - каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.  
* Доменно-ключевая нормальная форма (DKNF) - каждое наложенное на нее ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.  
* Шестая нормальная форма (6NF) - удовлетворяет всем нетривиальным зависимостям соединения, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Введена как обобщение пятой нормальной формы для хронологической базы данных.

### Что такое TIMESTAMP?
* DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере. Размер: 8 байт  
* TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. Тогда была создана Unix. При получении из базы отображается с учётом часового пояса. Размер: 4 байта

### Шардирование БД
При большом количестве данных запросы начинают долго выполняться, и сервер начинает не справляться с нагрузкой. Одно из решений, что с этими данными делать — это масштабирование базы данных. Например, шардинг или репликация.  
Шардинг бывает вертикальным(партицирование) и горизонтальным.У нас есть большая таблица, например, с пользователями. Партицирование — это когда мы одну большую таблицу разделяем на много маленьких по какому-либо принципу.  
Единственное отличие горизонтального масштабирования от вертикального в том, что горизонтальное будет разносить данные по разным инстансам в других базах.
![[SQL_Shard_1.png]]
Есть таблица news, в которой есть идентификатор, есть категория, в которой эта новость расположена, есть автор новости...  
Нужно сделать 2 действия над табличкой — это поставить у нашего шарда, например, news_1, то, что она будет наследоваться от news.  
Наследованная таблица будет иметь все колонки родителя, а также она может иметь свои колонки, которые мы дополнительно туда добавим. Там не будет ограничений, индексов и триггеров от родителя — это важно.2-ое действие — это поставить ограничения. Это будет проверка, что в эту таблицу будут попадать данные только с нужным признаком.
![[SQL_Shard_2.png]]
Т.е. только записи с category_id=1 будут попадать в эту таблицу.  
На базовую таблицу надо добавить правило. Когда мы будем работать с таблицей news, вставка на запись с category_id = 1 должна попасть именно в партицию news_1. Правило называем как хотим.
![[SQL_Shard_3.png]]

### EXPLAIN
**Когда вы выполняете какой-нибудь запрос, оптимизатор** запросов MySQL **пытается придумать оптимальный план выполнения этого запроса.** Можно посмотреть этот план используя запрос с ключевым словом EXPLAIN перед оператором SELECT.  
```sql
EXPLAIN SELECT * FROM categories
```
После EXPLAIN в запросе вы можете использовать ключевое слово EXTENDED и MySQL покажет вам дополнительную информацию о том, как выполняется запрос. Чтобы увидеть эту информацию, вам нужно сразу после запроса с EXTENDED выполнить запрос SHOW WARNINGS.  
```sql
EXPLAIN EXTENDED SELECT City.Name FROM City  
```
Затем  
```sql
SHOW WARNINGS
```

### Что такое «триггер»?
Триггер (trigger) — **это хранимая процедура особого типа, исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера.**  
Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события).